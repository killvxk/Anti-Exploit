#include <stdio.h>
#include <windows.h>
//#include <string.h>
//#include <iostream>


//using namespace std;

BOOL LoadDriver(void);
BOOL UnloadDriver(void);

HMODULE g_hDLL = NULL;
HANDLE kernel = 0;
int initFlag = 0;

const char MY_DRIVER[] = "stscae64";
char MY_PATH[MAX_PATH]="";


BOOL LoadDriver(void)
{
	SC_HANDLE hSCM;
	SC_HANDLE hService;


	GetCurrentDirectoryA(MAX_PATH, MY_PATH);
	strcat(MY_PATH, "\\stscae64.sys");

	//printf("%s\n", MY_PATH);
	hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (!hSCM) {
		printf("Unable to open the service control manager...\n");
		return FALSE;
	}
	hService = CreateService(hSCM,
		MY_DRIVER,
		MY_DRIVER,
		SERVICE_ALL_ACCESS,
		SERVICE_KERNEL_DRIVER,
		SERVICE_DEMAND_START,
		SERVICE_ERROR_NORMAL,
		MY_PATH,
		NULL,
		NULL,
		NULL,
		NULL,
		NULL);
	if (!hService) {
		hService = OpenService(hSCM, MY_DRIVER, SERVICE_ALL_ACCESS);
		if (!hService) {
			printf(" Unable to Create/open the Service...\n");
			CloseServiceHandle(hSCM);
			return FALSE;
		}
	}
	if (!StartService(hService, 0, NULL) &&
		(GetLastError() != ERROR_SERVICE_ALREADY_RUNNING)) {
		printf("Unable to start the Service ...\n"); 
		CloseServiceHandle(hSCM);
		CloseServiceHandle(hService);
		return FALSE;
	}
	CloseServiceHandle(hSCM);
	CloseServiceHandle(hService);
	return TRUE;
}
BOOL UnloadDriver(void)
{
	SC_HANDLE hSCM;
	SC_HANDLE hService;
	SERVICE_STATUS svcStatus;
	hSCM = OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
	if (!hSCM) {
		printf(" Unable to open the service contirol manager...\n");
		return FALSE;
	}
	hService = OpenService(hSCM, MY_DRIVER, SERVICE_ALL_ACCESS);
	if (!hService) {
		printf("Unable to open the service...\n");
		CloseServiceHandle(hSCM);
		return FALSE;
	}
	if (!ControlService(hService, SERVICE_CONTROL_STOP, &svcStatus)) {
		printf("Unable to stop the service...\n");
		CloseServiceHandle(hSCM);
		CloseServiceHandle(hService);
		return FALSE;
	}
	if (!DeleteService(hService)) {
		printf("Unable to delete the service ...\n");
		CloseServiceHandle(hSCM);
		CloseServiceHandle(hService);
		return FALSE;
	}
	CloseServiceHandle(hSCM);
	CloseServiceHandle(hService);
	return TRUE;
}


extern "C" __declspec(dllexport) void InitDriver(wchar_t val[])
{
	DWORD ret = 0;
	wchar_t dlldir[MAX_PATH];

	wcscpy(dlldir, val);
	//wprintf(L"--%s\n", dlldir);
	DWORD cc = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2000, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
	DeviceIoControl(kernel, cc, (LPVOID)&dlldir, MAX_PATH, (LPVOID)&dlldir, MAX_PATH, &ret, 0);
}
extern "C" __declspec(dllexport) void Change_Target(char val[])
{
	DWORD ret = -1;
	char processname[64];
	/*
	struct input
	{
		char processname[64];
	}*pinp;
	pinp = (input *)malloc(sizeof(input));
	*/
	strcpy(processname, val);

	DWORD cc = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2001, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
	DeviceIoControl(kernel, cc, (LPVOID)&processname, 128, (LPVOID)&processname, 128, &ret, 0);
	
	//free(pinp);
}

extern "C" __declspec(dllexport) void Clean_Target()
{
	DWORD ret = 0;
	
	DWORD cc = CTL_CODE(FILE_DEVICE_UNKNOWN, 0x2002, METHOD_BUFFERED, FILE_READ_ACCESS | FILE_WRITE_ACCESS);
	DeviceIoControl(kernel, cc, (LPVOID)NULL, 0, (LPVOID)NULL, 0, &ret, 0);
}

BOOL APIENTRY DllMain(HMODULE hModul, DWORD ul_reason_for_ca, LPVOID lpReserve)
{
	switch (ul_reason_for_ca)
	{
	case DLL_PROCESS_ATTACH:
		g_hDLL = hModul;
		//AllocConsole();
		//freopen("CON", "w", stdout);
		
		LoadDriver();
		kernel = CreateFileW(L"\\\\.\\Empire", 0xC0000000, 3u, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
		
		break;
	case DLL_THREAD_ATTACH:
		//UnloadDriver();
		//kernel = CreateFileW(L"\\\\.\\Empire", 0xC0000000, 3u, 0, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);


		//CloseHandle(kernel);
		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}
