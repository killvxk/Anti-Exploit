#include <windows.h>  
#include <stdlib.h>  
#include <stdio.h>  
#include <winioctl.h>  
#include <string.h>  
#include <crtdbg.h>  
#include <assert.h>  
#include <fltuser.h>  
#include <dontuse.h>  
#include "main.h"  
#include "Service.h"
#pragma comment(lib,"fltlib.lib")
#pragma comment(lib, "Advapi32.lib")

#define SCANNER_DEFAULT_REQUEST_COUNT       5  
#define SCANNER_DEFAULT_THREAD_COUNT        2  
#define SCANNER_MAX_THREAD_COUNT            64  

typedef struct _SCANNER_THREAD_CONTEXT {

	HANDLE Port;
	HANDLE Completion;

} SCANNER_THREAD_CONTEXT, *PSCANNER_THREAD_CONTEXT;

DWORD ScannerWorker(PSCANNER_THREAD_CONTEXT Context);


const char* S_NAME = "MsxSvc";
const char* S_DISP = "SaintSecurity Anti-Exploit Service";
const char* S_DESC = "SaintSecurity Anti-Exploit Service";
SERVICE_STATUS_HANDLE srvhd = 0;
DWORD                 srvst = SERVICE_STOPPED;


int main(int argc,char **argv)
{
	

	char S_BINARY[MAX_PATH] = { 0 };
	::GetModuleFileName(NULL, S_BINARY, MAX_PATH);

	if (argc == 2 && argv[1][0] == 'i')
	{
		ServiceInstall();
		return 0;
	}
	else if (argc == 2 && argv[1][0] == 'u')
	{
		ServiceUninstall();
		return 0;
	}

	SERVICE_TABLE_ENTRY STE[] =
	{
		{ (char*)S_NAME, (LPSERVICE_MAIN_FUNCTION)_tmain_service },
		{ NULL,NULL }
	};
	if (StartServiceCtrlDispatcher(STE) == FALSE)
		return -1;
	






	return 0;
}


DWORD ScannerWorker(PSCANNER_THREAD_CONTEXT Context)
{
	BOOL result;
	DWORD outSize;
	LPOVERLAPPED pOvlp;
	ULONG_PTR key;
	HRESULT hr;
	PSCANNER_MESSAGE message;
	PSCANNER_NOTIFICATION notification;
	SCANNER_REPLY_MESSAGE replyMessage;
	char buf[1024];
	while (TRUE)
	{
		result = GetQueuedCompletionStatus(Context->Completion, &outSize, &key, &pOvlp, INFINITE);
		message = CONTAINING_RECORD(pOvlp, SCANNER_MESSAGE, Ovlp);
		if (!result)
		{
			printf("GetQueuedCompletionStatus error \n");
			break;
		}

		notification = &message->Notification;
		//printf("%d %s %d\n", notification->bCreate, notification->ProcessName, pOvlp->InternalHigh);
		sprintf(buf, "%d %s", notification->bCreate, notification->ProcessName);
		OutputDebugStringA(buf);

		ZeroMemory(&replyMessage, sizeof(SCANNER_REPLY_MESSAGE));
		replyMessage.ReplyHeader.Status = 0;
		replyMessage.ReplyHeader.MessageId = message->MessageHeader.MessageId;
		replyMessage.Reply.SafeToOpen = 6;
		CopyMemory(replyMessage.Reply.ReplyMsg, "12345678ab", 10);

		hr = FilterReplyMessage(Context->Port, (PFILTER_REPLY_HEADER)&replyMessage, sizeof(replyMessage));
		if (SUCCEEDED(hr))
		{
			//printf("Replied message\n");
		}
		else
		{
			printf("Scanner: Error replying message. Error = 0x%X\n", hr);
			break;
		}

		memset(&message->Ovlp, 0, sizeof(OVERLAPPED));
		hr = FilterGetMessage(Context->Port, &message->MessageHeader, FIELD_OFFSET(SCANNER_MESSAGE, Ovlp), &message->Ovlp);
		if (hr != HRESULT_FROM_WIN32(ERROR_IO_PENDING))
		{
			printf("FilterGetMessage error\n");
			break;
		}

	}
	//printf("Finish \n");
	delete message;
	return 0;
}




int _tmain_service(INT ARGC, LPSTR* ARGV)
{
	DWORD requestCount = SCANNER_DEFAULT_REQUEST_COUNT;
	DWORD threadCount = SCANNER_DEFAULT_THREAD_COUNT;
	HANDLE port, completion;
	HRESULT hr;
	DWORD threadId;
	PSCANNER_MESSAGE msg;
	HANDLE threads[SCANNER_MAX_THREAD_COUNT];
	SCANNER_THREAD_CONTEXT context;
	int i = 0;

	// 서비스가 외부 제어 명령(시작, 중지, 다시 시작... etc) 을 받을 때, 그것을 받을 수 있도록 콜백형식의
	// 함수를 등록하는 것이다.
	srvhd = RegisterServiceCtrlHandlerEx(S_NAME, _tmain_service_handler, NULL);
	if (srvhd == NULL)
		return -1;
	//MessageBoxA(NULL, "AAAA", "BBBB", MB_OK);

	// 정상적으로 서비스가 시작되었다.
	SET_SERVICE_STATE(srvhd, SERVICE_RUNNING);

	// 무한 루프를 돌면서 띵띵~ 소리를 낸다.
	while (GET_SERVICE_STATE() != SERVICE_STOPPED)
	{
		if (GET_SERVICE_STATE() == SERVICE_PAUSED)
		{
			Sleep(1000);
			continue;
		}
		hr = FilterConnectCommunicationPort(L"\\CommunicationPort", 0, NULL, 0, NULL, &port);
		if (IS_ERROR(hr))
		{

			printf("ERROR: Connecting to filter port: 0x%08x\n", hr);
			//getchar();
			//getchar();
			//return 2;
			continue;
		}

		completion = CreateIoCompletionPort(port, NULL, 0, threadCount);
		if (completion == NULL)
		{

		//	printf("ERROR: Creating completion port: %d\n", GetLastError());
			CloseHandle(port);
			//getchar();
			//getchar();
			//return 3;
			continue;
		}

		context.Port = port;
		context.Completion = completion;



		for (i = 0; i < 2; i++)
		{

			threads[i] = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ScannerWorker, &context, 0, &threadId);
			if (threads[i] == NULL)
			{
				hr = GetLastError();
				printf("ERROR: Couldn't create thread: %d\n", hr);
				goto main_cleanup;
			}

			for (int j = 0; j < 2; j++)
			{


				msg = new SCANNER_MESSAGE[sizeof(SCANNER_MESSAGE)];
				if (msg == NULL)
				{

					hr = ERROR_NOT_ENOUGH_MEMORY;
					goto main_cleanup;
				}

				memset(&msg->Ovlp, 0, sizeof(OVERLAPPED));

				hr = FilterGetMessage(port, &msg->MessageHeader, FIELD_OFFSET(SCANNER_MESSAGE, Ovlp), &msg->Ovlp);
				if (hr != HRESULT_FROM_WIN32(ERROR_IO_PENDING))
				{

					delete msg;
					goto main_cleanup;
				}
			}

		}
		hr = S_OK;


		WaitForMultipleObjectsEx(i, threads, TRUE, INFINITE, FALSE);

	main_cleanup:

		printf("Scanner:  All done. Result = 0x%08x\n", hr);

		CloseHandle(port);
		CloseHandle(completion);
		
		//getchar();
		//getchar();





		Sleep(1000);
		continue;
	}

	return 0;
}



DWORD WINAPI _tmain_service_handler(DWORD fdwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)
{
	// 서비스라 좋은점이 있네, 시스템에서 발생하는 잡다구리한 이벤트들을 별로 힘들이지 않고
	// 이곳에서 받아다가 처리할 수 있다.

	switch (fdwControl)
	{
	case SERVICE_CONTROL_PAUSE:
		SET_SERVICE_STATE(srvhd, SERVICE_PAUSE_PENDING, 0);
		// 서비스를 일시 중지 시킨다.
		SET_SERVICE_STATE(srvhd, SERVICE_PAUSED);
		break;

	case SERVICE_CONTROL_CONTINUE:
		SET_SERVICE_STATE(srvhd, SERVICE_CONTINUE_PENDING, 0);
		// 일시 중지 시킨 서비스를 재개한다.
		SET_SERVICE_STATE(srvhd, SERVICE_RUNNING);
		break;

	case SERVICE_CONTROL_STOP:
		SET_SERVICE_STATE(srvhd, SERVICE_STOP_PENDING, 0);
		// 서비스를 멈춘다 (즉, 종료와 같은 의미)
		SET_SERVICE_STATE(srvhd, SERVICE_STOPPED);
		break;

	default:
		break;
	}

	return NO_ERROR;
}
