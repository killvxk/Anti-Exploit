#include <Windows.h>
#include <stdio.h>
#include "wintoastlib.h"
#include "main.h"
#include "resource.h"
#include <WinInet.h>
#include <OleAuto.h>
#include "resource.h"
#include "stsc_util.h"
#include "main.h"


/* Old Hook 모두 지울 예정 */
BYTE CreateProcessW_hook[6];
BYTE CreateProcessA_hook[6];
BYTE CreateProcessW64_hook[14];
BYTE CreateProcessA64_hook[14];
BYTE HttpSendRequestW64_hook[14];
BYTE HttpSendRequestA64_hook[14];
BYTE send64_hook[14];
BYTE send_hook[6];
BYTE recv64_hook[14];
BYTE recv_hook[6];
BYTE free64_hook[14];
BYTE free_hook[6];
BYTE LdrLoadDll64_hook[14];
BYTE LdrLoadDll_hook[6];
BYTE LoadLibraryExA64_hook[14];
BYTE LoadLibraryExA_hook[6];
BYTE LoadLibraryExW64_hook[14];
BYTE LoadLibraryExW_hook[6];
BYTE HttpSendRequestW_hook[6];
BYTE HttpSendRequestA_hook[6];
BYTE SysAllocString64_hook[14];
BYTE SysAllocString_hook[6];
BYTE jmp[6] = { 0xe9, 0x00, 0x00, 0x00, 0x00, 0xc3 };
BYTE jmp64[14] = { 0x68, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x04 , 0x00,0x00,0x00,0x00,0xC3 };


LPVOID(WINAPI *HeapAllocNext)(_In_ HANDLE hHeap, _In_ DWORD  dwFlags, _In_ SIZE_T dwBytes);
ULONG(WINAPI *CreateProcessWNext) (LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment,
LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
UINT(WINAPI *WinExecNext)(_In_ LPCSTR lpCmdLine, _In_ UINT   uCmdShow);
HINSTANCE(WINAPI *ShellExecuteWNext)(_In_opt_ HWND    hwnd, _In_opt_ LPCTSTR lpOperation, _In_     LPCTSTR lpFile, _In_opt_ LPCTSTR lpParameters, _In_opt_ LPCTSTR lpDirectory, _In_ INT nShowCmd);
HMODULE(WINAPI *LoadLibraryExWNext)(_In_ LPCTSTR lpFileName, _Reserved_ HANDLE  hFile, _In_  DWORD  dwFlags);
HMODULE(WINAPI *GetModuleHandleWNext)(_In_opt_ LPCTSTR lpModuleName);
int(*systemNext)(const char *command);
int(*_wsystemNext)(const wchar_t *command);
HRESULT(*URLDownloadToFileWNext)(LPUNKNOWN pCaller, LPCTSTR szURL, LPCWSTR szFileName, _Reserved_ DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB);
HRESULT(*URLDownloadToFileANext)(LPUNKNOWN pCaller, LPCTSTR szURL, LPCSTR szFileName, _Reserved_ DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB);
BOOL(WINAPI *InternetReadFileNext)(_In_ HINTERNET hFile, _Out_ LPVOID lpBuffer, _In_  DWORD dwNumberOfBytesToRead, _Out_ LPDWORD lpdwNumberOfBytesRead);
BOOL(WINAPI *InternetReadFileExWNext)(_In_  HINTERNET hFile, _Out_ LPINTERNET_BUFFERS lpBuffersOut, _In_  DWORD dwFlags, _In_  DWORD_PTR dwContext);
LPVOID(WINAPI *VirtualAllocNext)(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD  flAllocationType, _In_ DWORD  flProtect);
HANDLE(WINAPI *HeapCreateNext)(DWORD  flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
BOOL(WINAPI *WriteProcessMemoryNext)(HANDLE  hProcess, LPVOID  lpBaseAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten);
BOOL(WINAPI *VirtualProtectNext)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect);
BOOL(WINAPI *SetProcessDEPPolicyNext)(_In_ DWORD dwFlags);

#ifdef _WIN64
extern "C" int __stdcall get_ret64(unsigned long long *ret,BYTE * opcode);
#endif




void Detect_Func(int type=0)
{
	/*
	NOTIFYICONDATA niData;

	ZeroMemory(&niData, sizeof(NOTIFYICONDATA));
	niData.cbSize = sizeof(NOTIFYICONDATA);
	niData.hWnd = NULL;
	niData.uID = 100;
	niData.dwInfoFlags = 1;
	niData.uTimeout = 1000;
	niData.uVersion = NOTIFYICON_VERSION_4;
	niData.uFlags = 16;
	niData.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wcscpy_s(niData.szInfoTitle, L"SaintSecurity");
	wcscpy_s(niData.szInfo, L"Detect");
	//wcscpy_s(niData.szTip, L"CCCC");
	//niData.uCallbackMessage = NOTIFICATION_TRAY_ICON_MSG;
	Shell_NotifyIcon(NIM_ADD, &niData);
	Shell_NotifyIcon(NIM_DELETE, &niData);
	*/
	switch (type)
	{
	case 0:
		strcpy(detect_name, "00000");
		
		break;
	case 1:
		strcpy(detect_name, "ROP Gadget Detect!");
		break;

	case 2:
		strcpy(detect_name, "Heap Execution Detect!");
		break;
	case 3:
		strcpy(detect_name, "Unsigned file Execution Detect!");
		break;
	}

	DialogBoxW(g_hDLL, (LPCTSTR)101, NULL, (DLGPROC)DialogProc); //101 -> IDD_DIALOG1

}

BOOL MemoryEdit(VOID *lpMem, VOID *lpSrc, DWORD len)
{
	DWORD lpflOldProtect, flNewProtect = PAGE_READWRITE;
	unsigned char * pDst = (unsigned char *)lpMem,
		*pSrc = (unsigned char *)lpSrc;
	if (VirtualProtect(lpMem, len, flNewProtect, &lpflOldProtect))
	{
		while (len-- > 0) *pDst++ = *pSrc++;
		return(0);
	}
	return(1);
}

DWORD HookFunction(LPCSTR lpModule, LPCSTR lpFuncName, LPVOID lpFunction, unsigned char *lpBackup)
{
	DWORD dwAddr = (DWORD)GetProcAddress(GetModuleHandleA(lpModule), lpFuncName);
	ReadProcessMemory(GetCurrentProcess(), (LPVOID)dwAddr, lpBackup, 6, 0);

	DWORD dwCalc = ((DWORD)lpFunction - dwAddr - 5);
	memcpy(&jmp[1], &dwCalc, 4);
	WriteProcessMemory(GetCurrentProcess(), (LPVOID)dwAddr, jmp, 6, 0);
	return dwAddr;
}

BOOL UnHookFunction(LPCSTR lpModule, LPCSTR lpFuncName, unsigned char *lpBackup)
{
	DWORD dwAddr = (DWORD)GetProcAddress(GetModuleHandleA(lpModule), lpFuncName);
	if (WriteProcessMemory(GetCurrentProcess(), (LPVOID)dwAddr, lpBackup, 6, 0))
		return TRUE;
	return FALSE;
}

DWORD HookFunction64(LPCSTR lpModule, LPCSTR lpFuncName, LPVOID lpFunction, unsigned char *lpBackup)
{


	DWORD64 dwAddr = (DWORD64)GetProcAddress(GetModuleHandleA(lpModule), lpFuncName);
	ReadProcessMemory(GetCurrentProcess(), (LPVOID)dwAddr, lpBackup, 14, 0);



	DWORD dwCalc = ((DWORD64)lpFunction) & 0x00000000FFFFFFFF;
	memcpy(&jmp64[1], &dwCalc, 4);
	dwCalc = ((((DWORD64)lpFunction) & 0xFFFFFFFF00000000) >> 32);
	memcpy(&jmp64[9], &dwCalc, 4);

	WriteProcessMemory(GetCurrentProcess(), (LPVOID)dwAddr, jmp64, 14, 0);
	return dwAddr;
}

BOOL UnHookFunction64(LPCSTR lpModule, LPCSTR lpFuncName, unsigned char *lpBackup)
{
	DWORD64 dwAddr = (DWORD64)GetProcAddress(GetModuleHandleA(lpModule), lpFuncName);
	if (WriteProcessMemory(GetCurrentProcess(), (LPVOID)dwAddr, lpBackup, 14, 0))
		return TRUE;
	return FALSE;
}

bool bCompare(const BYTE* pData, const BYTE* bMask, const char* szMask)
{
	for (; *szMask; ++szMask, ++pData, ++bMask)
		if (*szMask == 'x' && *pData != *bMask) return 0;
	return (*szMask) == NULL;
}

BYTE * FindPattern(DWORD dwAddress, DWORD dwLen, BYTE *bMask, char * szMask)
{
	for (DWORD i = 0; i<dwLen; i++)
		if (bCompare((BYTE*)(dwAddress + i), bMask, szMask)) return (BYTE *)(dwAddress + i);
	return 0;
}


/*Old Hook*/
void _cdecl nFree(void *memblock)
{
#ifdef _WIN64
	UnHookFunction64("msvcrt.dll", "free", free64_hook);
#else
	UnHookFunction("msvcrt.dll", "free", free_hook);
#endif

	printf("Free1: %x\n", memblock);
	
	
	free(memblock);
	printf("Free2: %x\n", memblock);

#ifdef _WIN64
	HookFunction64("msvcrt.dll", "free", (LPVOID*)nFree, free64_hook);
#else
	HookFunction("msvcrt.dll", "free", (LPVOID*)nFree, free_hook);
#endif
}

int WINAPI nSend(SOCKET s, char *buf, int len, int flags) {

#ifdef _WIN64
	UnHookFunction64("ws2_32.dll", "send", send64_hook);
#else
	UnHookFunction("ws2_32.dll", "send", send_hook);
#endif

	printf("Send: %s\n" ,buf);
	int result = send(s, buf, len, flags);


#ifdef _WIN64
	HookFunction64("ws2_32.dll", "send", (LPVOID*)nSend, send64_hook);
#else
	HookFunction("ws2_32.dll", "send", (LPVOID*)nSend, send_hook);
#endif
	return result;
}

int WINAPI nRecv(SOCKET s, char *buf, int len, int flags) {

#ifdef _WIN64
	UnHookFunction64("ws2_32.dll", "recv", recv64_hook);
#else
	UnHookFunction("ws2_32.dll", "recv", recv_hook);
#endif


	int result = recv(s, buf, len, flags);
	
	if (result > 30)
	{
		//printf("Recv: %s\n", buf);
	}
#ifdef _WIN64
	HookFunction64("ws2_32.dll", "recv", (LPVOID*)nRecv, recv64_hook);
#else
	HookFunction("ws2_32.dll", "recv", (LPVOID*)nRecv, recv_hook);
#endif
	return result;
}
typedef NTSTATUS(*LdrLoadDll)(PWCHAR a0, ULONG a1, PVOID a2, PHANDLE a3);
NTSTATUS NTAPI  nLdrLoadDll(PWCHAR a0, ULONG a1, PVOID a2, PHANDLE a3)
{
	
#ifdef _WIN64
	UnHookFunction64("ntdll.dll", "LdrLoadDll", LdrLoadDll64_hook);
#else
	UnHookFunction("ntdll.dll", "LdrLoadDll", LdrLoadDll_hook);
#endif

//	wprintf(L"11111111");


	HMODULE hDLL = LoadLibrary(L"ntdll.dll");
	//wprintf(L"222222222");
	LdrLoadDll A = (LdrLoadDll)GetProcAddress((HMODULE)hDLL, "LdrLoadDll");
	//wprintf(L"%lx",A);
	
	
	

	LONG result = A( a0,  a1,  a2,  a3);
	//wprintf(L"LoadLibrary(%s)\n", a1);

	


#ifdef _WIN64
	HookFunction64("ntdll.dll", "LdrLoadDll", (LPVOID*)nLdrLoadDll, LdrLoadDll64_hook);
#else
	HookFunction("ntdll.dll", "LdrLoadDll", (LPVOID*)nLdrLoadDll, LdrLoadDll_hook);
#endif
	return result;
}

HMODULE WINAPI  nLoadLibraryExA(LPCSTR lpFileName,HANDLE  hFile,DWORD  dwFlags)
{
	
	
#ifdef _WIN64
	UnHookFunction64("kernel32.dll", "LoadLibraryExA", LoadLibraryExA64_hook);
#else
	UnHookFunction("kernel32.dll", "LoadLibraryExA", LoadLibraryExA_hook);
#endif

	//printf("1");
	printf("%s %d %d\n", lpFileName,hFile,dwFlags);
	HMODULE result= LoadLibraryExA(lpFileName,  hFile,  dwFlags);
	printf("GOOD\n");
#ifdef _WIN64
	HookFunction64("kernel32.dll", "LoadLibraryExA", (LPVOID*)nLoadLibraryExA, LoadLibraryExA64_hook);
#else
	HookFunction("kernel32.dll", "LoadLibraryExA", (LPVOID*)nLoadLibraryExA, LoadLibraryExA_hook);
#endif

	
	return result;
}

HMODULE WINAPI  nLoadLibraryExW(LPCTSTR lpFileName, HANDLE  hFile, DWORD  dwFlags)
{

#ifdef _WIN64
	UnHookFunction64("kernel32.dll", "LoadLibraryExW", LoadLibraryExW64_hook);
#else
	UnHookFunction("kernel32.dll", "LoadLibraryExW", LoadLibraryExW_hook);
#endif

	wprintf(L"%s\n", lpFileName);
	HMODULE result = LoadLibraryExW(lpFileName, hFile, dwFlags);

#ifdef _WIN64
	HookFunction64("kernel32.dll", "LoadLibraryExW", (LPVOID*)nLoadLibraryExW, LoadLibraryExW64_hook);
#else
	HookFunction("kernel32.dll", "LoadLibraryExW", (LPVOID*)nLoadLibraryExW, LoadLibraryExW_hook);
#endif
	return result;
}

BSTR WINAPI nSysAllocString(_In_opt_ const OLECHAR *psz)
{
#ifdef _WIN64
	UnHookFunction64("OleAut32.dll", "SysAllocString", SysAllocString64_hook);
#else
	
#endif

	BSTR result = SysAllocString(psz);
	if (wcslen(psz) > 20)
	{
		wprintf(L"psz: %s\n", result);

	}
	

#ifdef _WIN64
	HookFunction64("OleAut32.dll", "SysAllocString", (LPVOID*)nSysAllocString, SysAllocString64_hook);
#else
	
#endif
	return result;
}

BOOL WINAPI nHttpSendRequestW(HINTERNET hRequest, LPCWSTR lpszHeaders, DWORD dwHeadersLength, LPVOID lpOptional, DWORD dwOptionalLength)
{
#ifdef _WIN64
	UnHookFunction64("wininet.dll", "HttpSendRequestW", HttpSendRequestW64_hook);
#else
	UnHookFunction("wininet.dll", "HttpSendRequestW", HttpSendRequestW_hook);
#endif

	//printf("힝\n");
	BOOL ret = HttpSendRequestW(hRequest, lpszHeaders, dwHeadersLength, lpOptional, dwOptionalLength);
	//BOOL ret = -1;

	//wprintf(L"%s\n", lpszHeaders);
#ifdef _WIN64
	HookFunction64("wininet.dll", "HttpSendRequestW", (LPVOID*)nHttpSendRequestW, HttpSendRequestW64_hook);
#else
	HookFunction("wininet.dll", "HttpSendRequestW", (LPVOID*)nHttpSendRequestW, HttpSendRequestW_hook);
#endif



	return ret;
}

BOOL WINAPI nCreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
{
#ifdef _WIN64
	UnHookFunction64("kernel32.dll", "CreateProcessW", CreateProcessW64_hook);
#else
	UnHookFunction("kernel32.dll", "CreateProcessW", CreateProcessW_hook);
#endif

	wprintf(L"RUN: %s %s %s\n\n", lpApplicationName, lpCommandLine, lpCurrentDirectory);
	//C:\Users\Kang\AppData\Local\Microsoft\Windows\INetCache\IE\SDGBB2TD\

	//Sleep(5000);

	BOOL ret = -1;

	if (!_stricmp(PROCESS_NAME, "iexplore.exe") && bit == TRUE)
	{
		Detect_Func();
	}
	else if (!_stricmp(PROCESS_NAME, "wscript.exe") && bit == FALSE)
	{
		//if()

		DWORD isSigned = VerifyEmbeddedSignature(lpApplicationName);
		if (isSigned)
		{
			Detect_Func(3);
		}
		else
		{
			ret = CreateProcessW(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
		}
	}
	else
	{
		ret = CreateProcessW(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
	}



	/*

	*/


	/*
	if (OSver >= 1)
	{

	NOTIFYICONDATA nid;
	ZeroMemory(&nid, sizeof(nid));
	nid.cbSize = sizeof(NOTIFYICONDATA);
	nid.hWnd = (HWND)GetModuleHandleA(NULL);
	nid.uFlags = NIF_ICON | NIF_TIP | NIF_INFO;
	//nid.hIcon = LoadIcon(g_hInst, IDR_MAINFRAME);
	lstrcpy(nid.szTip, L"detect");
	lstrcpy(nid.szInfo, L"[*]프로세스 실행을 차단하였습니다.");

	Shell_NotifyIcon(NIM_ADD, &nid);

	}
	else if (OSver == 1) //Windows 7
	{
	1 + 1;
	}

	*/


#ifdef _WIN64
	HookFunction64("kernel32.dll", "CreateProcessW", (LPVOID*)nCreateProcessW, CreateProcessW64_hook);
#else
	HookFunction("kernel32.dll", "CreateProcessW", (LPVOID*)nCreateProcessW, CreateProcessW_hook);
#endif



	return ret;
}






LPVOID WINAPI HeapAllocCallback(_In_ HANDLE hHeap, _In_ DWORD  dwFlags, _In_ SIZE_T dwBytes)
{

	LPVOID ret = HeapAllocNext(hHeap, dwFlags, dwBytes);
	
	return ret;
}

ULONG WINAPI CreateProcessWCallback(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
{
	//wprintf(L"%s %s\n", lpApplicationName, lpCommandLine);

	if (!_stricmp(PROCESS_NAME, "wscript.exe") && bit == FALSE)
	{
		DWORD isSigned = VerifyEmbeddedSignature(lpApplicationName);
		if (isSigned)
		{
			Detect_Func(3);
		}
	}

	return CreateProcessWNext(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);

}

UINT WINAPI WinExecCallback(_In_ LPCSTR lpCmdLine, _In_ UINT   uCmdShow)
{
#ifdef _WIN64
	unsigned long long ret;
	BYTE call_op;
	//get_ret64(&ret, &call_op);
	
	ret = (unsigned long long)_ReturnAddress();
	call_op=*((BYTE *)ret - 6);
	
#else
	DWORD ret;
	BYTE call_op;
	DWORD _esp;
	
	__asm
	{
		mov eax, esp;
		mov _esp, eax
	}
	
	ret=(DWORD)_ReturnAddress();
	call_op = *((BYTE *)ret - 5);

	
#endif

	MEMORY_BASIC_INFORMATION mbi;
	VirtualQueryEx(GetCurrentProcess(), (LPCVOID)ret, &mbi, 0x1c);
	
	if (call_op != 0xe8 && bit==TRUE)
	{
		Detect_Func(1);
	}
	else if (call_op != 0xFF && bit == FALSE) // JMP Func , Call register
	{
		Detect_Func(1);
	}
	else if (mbi.Type == MEM_PRIVATE) // Heap Execution  << Stack aslr DEP ON
	{
		Detect_Func(2);
	}

	

	return WinExecNext(lpCmdLine, uCmdShow);

}

HINSTANCE ShellExecuteWCallback(_In_opt_ HWND    hwnd, _In_opt_ LPCTSTR lpOperation, _In_     LPCTSTR lpFile, _In_opt_ LPCTSTR lpParameters, _In_opt_ LPCTSTR lpDirectory, _In_ INT nShowCmd)
{


#ifdef _WIN64
	unsigned long long ret;
	BYTE call_op;
	get_ret64(&ret, &call_op);

	//ret = *(&ret + 3);
	//call_op = 1;
	//printf("ret = %llx %x\n", ret, call_op);
	if (call_op != 0xFF)
	{
		Detect_Func(1);
	}
#else
	DWORD ret;
	BYTE call_op;
	

	
#endif

	printf("ShellExecute Called..\n");


	Sleep(5000);
	return ShellExecuteWNext(hwnd, lpOperation, lpFile, lpParameters,lpDirectory,nShowCmd);

}

HMODULE WINAPI LoadLibraryExWCallback(_In_ LPCTSTR lpFileName, _Reserved_ HANDLE  hFile, _In_  DWORD  dwFlags)
{
#ifdef SP
	printf("LoadLibraryExW Called...\n");
#endif
	return LoadLibraryExWNext(lpFileName, hFile, dwFlags);
}

HMODULE WINAPI GetModuleHandleWCallback(_In_opt_ LPCTSTR lpModuleName)
{
#ifdef SP
	printf("GetModuleHandleW Called...\n");
#endif
	return GetModuleHandleWNext(lpModuleName);
}

int systemCallback(const char *command)
{
#ifdef SP
	printf("system Called...\n");
#endif
	return systemNext(command);
}

int _wsystemCallback(const wchar_t *command)
{
#ifdef SP
	printf("_wsystem Called...\n");
#endif
	return _wsystemNext(command);
}

HRESULT URLDownloadToFileWCallback(LPUNKNOWN pCaller, LPCTSTR szURL, LPCWSTR szFileName, _Reserved_ DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB)
{
#ifdef SP
	printf("URLDownloadToFileW Called...\n");
#endif
	return URLDownloadToFileWNext(pCaller,szURL,szFileName,dwReserved,lpfnCB);
}

HRESULT URLDownloadToFileACallback(LPUNKNOWN pCaller, LPCTSTR szURL, LPCSTR szFileName, _Reserved_ DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB)
{
#ifdef SP
	printf("URLDownloadToFileA Called...\n");
#endif
	return URLDownloadToFileANext(pCaller, szURL, szFileName, dwReserved, lpfnCB);
}

BOOL WINAPI InternetReadFileCallback(_In_ HINTERNET hFile, _Out_ LPVOID lpBuffer, _In_  DWORD dwNumberOfBytesToRead, _Out_ LPDWORD lpdwNumberOfBytesRead)
{
#ifdef SP
	//printf("InternetReadFile Called...\n");
#endif
	BOOL ret = InternetReadFileNext(hFile, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
	//printf("Content: %s\n", lpBuffer);
	return ret;
}

BOOL WINAPI InternetReadFileExWCallback(_In_  HINTERNET hFile, _Out_ LPINTERNET_BUFFERSW lpBuffersOut, _In_  DWORD dwFlags, _In_  DWORD_PTR dwContext)
{
#ifdef SP
	//printf("InternetReadFileExW Called...\n");
#endif
	BOOL ret= InternetReadFileExWNext(hFile, lpBuffersOut, dwFlags, dwContext);
	//wprintf(L"S_Content: %ws\n", lpBuffersOut->lpvBuffer);
	return ret;
}

LPVOID WINAPI VirtualAllocCallback(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD  flAllocationType, _In_ DWORD  flProtect)
{
#ifdef SP
	//printf("VirtualAlloc Called...\n");
#endif
	LPVOID ret = VirtualAllocNext(lpAddress, dwSize, flAllocationType, flProtect);
	return ret;
}

HANDLE WINAPI HeapCreateCallback(DWORD  flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
{
#ifdef SP
	//printf("HeapCreate Called...\n");
#endif
	HANDLE ret = HeapCreateNext(flOptions, dwInitialSize, dwMaximumSize);
	return ret;
}

BOOL WINAPI WriteProcessMemoryCallback(HANDLE  hProcess, LPVOID  lpBaseAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten)
{
#ifdef SP
	//printf("WriteProcessMemory Called...\n");
#endif
	BOOL ret = WriteProcessMemoryNext(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
	return ret;
}

BOOL WINAPI VirtualProtectCallback(LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect)
{
#ifdef SP
	//printf("VirtualProtect Called...\n");
#endif


#ifdef _WIN64
	unsigned long long ret;
	BYTE call_op;
	BYTE call_op2;
	//get_ret64(&ret, &call_op);

	ret = (unsigned long long)_ReturnAddress();
	call_op = *((BYTE *)ret - 5);
	call_op2 = *((BYTE *)ret - 6);


#else
	DWORD ret;
	BYTE call_op;
	BYTE call_op2;
	DWORD _esp;

	__asm
	{
		mov eax, esp;
		mov _esp, eax
	}

	ret = (DWORD)_ReturnAddress();
	call_op = *((BYTE *)ret - 5);
	call_op2 = *((BYTE *)ret - 6);

#endif

	MEMORY_BASIC_INFORMATION mbi;
	VirtualQueryEx(GetCurrentProcess(), (LPCVOID)ret, &mbi, 0x1c);

	//printf(">> %d\n", bit);
	if ( call_op != 0xE8 && call_op2!=0xFF)
	{
		Detect_Func(1);
	}

	else if (mbi.Type == MEM_PRIVATE) // Heap Execution  << Stack aslr DEP ON
	{
		Detect_Func(2);
	}




	BOOL OriFunc_ret = VirtualProtectNext(lpAddress, dwSize, flNewProtect, lpflOldProtect);
	return OriFunc_ret;

}

BOOL WINAPI SetProcessDEPPolicyCallback(_In_ DWORD dwFlags)
{
#ifdef SP
	//printf("SetProcessDEPPolicy Called...\n");
#endif
	BOOL ret = SetProcessDEPPolicyNext(dwFlags);
	return ret;
}

