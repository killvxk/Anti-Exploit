#include <Windows.h>
#include <stdio.h>
#include "wintoastlib.h"
#include "main.h"
#include "resource.h"
#include <WinInet.h>
#include <OleAuto.h>
#include "resource.h"
#include "stsc_util.h"
#include "main.h"





LPVOID(WINAPI *HeapAllocNext)(_In_ HANDLE hHeap, _In_ DWORD  dwFlags, _In_ SIZE_T dwBytes);
ULONG(WINAPI *CreateProcessWNext) (LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment,
LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation);
UINT(WINAPI *WinExecNext)(_In_ LPCSTR lpCmdLine, _In_ UINT   uCmdShow);
HINSTANCE(WINAPI *ShellExecuteWNext)(_In_opt_ HWND    hwnd, _In_opt_ LPCTSTR lpOperation, _In_     LPCTSTR lpFile, _In_opt_ LPCTSTR lpParameters, _In_opt_ LPCTSTR lpDirectory, _In_ INT nShowCmd);
HMODULE(WINAPI *LoadLibraryExWNext)(_In_ LPCTSTR lpFileName, _Reserved_ HANDLE  hFile, _In_  DWORD  dwFlags);
HMODULE(WINAPI *GetModuleHandleWNext)(_In_opt_ LPCTSTR lpModuleName);
int(*systemNext)(const char *command);
int(*_wsystemNext)(const wchar_t *command);
HRESULT(*URLDownloadToFileWNext)(LPUNKNOWN pCaller, LPCTSTR szURL, LPCWSTR szFileName, _Reserved_ DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB);
HRESULT(*URLDownloadToFileANext)(LPUNKNOWN pCaller, LPCTSTR szURL, LPCSTR szFileName, _Reserved_ DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB);
BOOL(WINAPI *InternetReadFileNext)(_In_ HINTERNET hFile, _Out_ LPVOID lpBuffer, _In_  DWORD dwNumberOfBytesToRead, _Out_ LPDWORD lpdwNumberOfBytesRead);
BOOL(WINAPI *InternetReadFileExWNext)(_In_  HINTERNET hFile, _Out_ LPINTERNET_BUFFERS lpBuffersOut, _In_  DWORD dwFlags, _In_  DWORD_PTR dwContext);
LPVOID(WINAPI *VirtualAllocNext)(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD  flAllocationType, _In_ DWORD  flProtect);
HANDLE(WINAPI *HeapCreateNext)(DWORD  flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);
BOOL(WINAPI *WriteProcessMemoryNext)(HANDLE  hProcess, LPVOID  lpBaseAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten);
BOOL(WINAPI *VirtualProtectNext)(LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect);
BOOL(WINAPI *SetProcessDEPPolicyNext)(_In_ DWORD dwFlags);

#ifdef _WIN64
extern "C" int __stdcall get_ret64(unsigned long long *ret,BYTE * opcode);
#endif




void Detect_Func(int type=0)
{
	/*
	NOTIFYICONDATA niData;

	ZeroMemory(&niData, sizeof(NOTIFYICONDATA));
	niData.cbSize = sizeof(NOTIFYICONDATA);
	niData.hWnd = NULL;
	niData.uID = 100;
	niData.dwInfoFlags = 1;
	niData.uTimeout = 1000;
	niData.uVersion = NOTIFYICON_VERSION_4;
	niData.uFlags = 16;
	niData.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wcscpy_s(niData.szInfoTitle, L"SaintSecurity");
	wcscpy_s(niData.szInfo, L"Detect");
	//wcscpy_s(niData.szTip, L"CCCC");
	//niData.uCallbackMessage = NOTIFICATION_TRAY_ICON_MSG;
	Shell_NotifyIcon(NIM_ADD, &niData);
	Shell_NotifyIcon(NIM_DELETE, &niData);
	*/
	switch (type)
	{
	case 0:
		strcpy(detect_name, "00000");
		
		break;
	case 1:
		strcpy(detect_name, "ROP Gadget Detect!");
		break;

	case 2:
		strcpy(detect_name, "Heap Execution Detect!");
		break;
	case 3:
		strcpy(detect_name, "Unsigned file Execution Detect!");
		break;
	}

	DialogBoxW(g_hDLL, (LPCTSTR)101, NULL, (DLGPROC)DialogProc); //101 -> IDD_DIALOG1

}


LPVOID WINAPI HeapAllocCallback(_In_ HANDLE hHeap, _In_ DWORD  dwFlags, _In_ SIZE_T dwBytes)
{

	LPVOID ret = HeapAllocNext(hHeap, dwFlags, dwBytes);
	
	return ret;
}

ULONG WINAPI CreateProcessWCallback(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
{
	//wprintf(L"%s %s\n", lpApplicationName, lpCommandLine);

	if (!_stricmp(PROCESS_NAME, "wscript.exe") && bit == FALSE)
	{
		DWORD isSigned = VerifyEmbeddedSignature(lpApplicationName);
		if (isSigned)
		{
			Detect_Func(3);
		}
	}

	return CreateProcessWNext(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);

}

UINT WINAPI WinExecCallback(_In_ LPCSTR lpCmdLine, _In_ UINT   uCmdShow)
{
#ifdef _WIN64
	unsigned long long ret;
	BYTE call_op;
	//get_ret64(&ret, &call_op);
	
	ret = (unsigned long long)_ReturnAddress();
	call_op=*((BYTE *)ret - 6);
	
#else
	DWORD ret;
	BYTE call_op;
	DWORD _esp;
	
	__asm
	{
		mov eax, esp;
		mov _esp, eax
	}
	
	ret=(DWORD)_ReturnAddress();
	call_op = *((BYTE *)ret - 5);

	
#endif

	MEMORY_BASIC_INFORMATION mbi;
	VirtualQueryEx(GetCurrentProcess(), (LPCVOID)ret, &mbi, 0x1c);
	
	if (call_op != 0xe8 && bit==TRUE)
	{
		Detect_Func(1);
	}
	else if (call_op != 0xFF && bit == FALSE) // JMP Func , Call register
	{
		Detect_Func(1);
	}
	else if (mbi.Type == MEM_PRIVATE) // Heap Execution  << Stack aslr DEP ON
	{
		Detect_Func(2);
	}

	

	return WinExecNext(lpCmdLine, uCmdShow);

}

HINSTANCE ShellExecuteWCallback(_In_opt_ HWND    hwnd, _In_opt_ LPCTSTR lpOperation, _In_     LPCTSTR lpFile, _In_opt_ LPCTSTR lpParameters, _In_opt_ LPCTSTR lpDirectory, _In_ INT nShowCmd)
{


#ifdef _WIN64
	unsigned long long ret;
	BYTE call_op;
	get_ret64(&ret, &call_op);

	//ret = *(&ret + 3);
	//call_op = 1;
	//printf("ret = %llx %x\n", ret, call_op);
	if (call_op != 0xFF)
	{
		Detect_Func(1);
	}
#else
	DWORD ret;
	BYTE call_op;
	

	
#endif

	printf("ShellExecute Called..\n");


	Sleep(5000);
	return ShellExecuteWNext(hwnd, lpOperation, lpFile, lpParameters,lpDirectory,nShowCmd);

}

HMODULE WINAPI LoadLibraryExWCallback(_In_ LPCTSTR lpFileName, _Reserved_ HANDLE  hFile, _In_  DWORD  dwFlags)
{
#ifdef SP
	printf("LoadLibraryExW Called...\n");
#endif
	return LoadLibraryExWNext(lpFileName, hFile, dwFlags);
}

HMODULE WINAPI GetModuleHandleWCallback(_In_opt_ LPCTSTR lpModuleName)
{
#ifdef SP
	printf("GetModuleHandleW Called...\n");
#endif
	return GetModuleHandleWNext(lpModuleName);
}

int systemCallback(const char *command)
{
#ifdef SP
	printf("system Called...\n");
#endif
	return systemNext(command);
}

int _wsystemCallback(const wchar_t *command)
{
#ifdef SP
	printf("_wsystem Called...\n");
#endif
	return _wsystemNext(command);
}

HRESULT URLDownloadToFileWCallback(LPUNKNOWN pCaller, LPCTSTR szURL, LPCWSTR szFileName, _Reserved_ DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB)
{
#ifdef SP
	printf("URLDownloadToFileW Called...\n");
#endif
	return URLDownloadToFileWNext(pCaller,szURL,szFileName,dwReserved,lpfnCB);
}

HRESULT URLDownloadToFileACallback(LPUNKNOWN pCaller, LPCTSTR szURL, LPCSTR szFileName, _Reserved_ DWORD dwReserved, LPBINDSTATUSCALLBACK lpfnCB)
{
#ifdef SP
	printf("URLDownloadToFileA Called...\n");
#endif
	return URLDownloadToFileANext(pCaller, szURL, szFileName, dwReserved, lpfnCB);
}

BOOL WINAPI InternetReadFileCallback(_In_ HINTERNET hFile, _Out_ LPVOID lpBuffer, _In_  DWORD dwNumberOfBytesToRead, _Out_ LPDWORD lpdwNumberOfBytesRead)
{
#ifdef SP
	//printf("InternetReadFile Called...\n");
#endif
	BOOL ret = InternetReadFileNext(hFile, lpBuffer, dwNumberOfBytesToRead, lpdwNumberOfBytesRead);
	//printf("Content: %s\n", lpBuffer);
	return ret;
}

BOOL WINAPI InternetReadFileExWCallback(_In_  HINTERNET hFile, _Out_ LPINTERNET_BUFFERSW lpBuffersOut, _In_  DWORD dwFlags, _In_  DWORD_PTR dwContext)
{
#ifdef SP
	//printf("InternetReadFileExW Called...\n");
#endif
	BOOL ret= InternetReadFileExWNext(hFile, lpBuffersOut, dwFlags, dwContext);
	//wprintf(L"S_Content: %ws\n", lpBuffersOut->lpvBuffer);
	return ret;
}

LPVOID WINAPI VirtualAllocCallback(_In_opt_ LPVOID lpAddress, _In_ SIZE_T dwSize, _In_ DWORD  flAllocationType, _In_ DWORD  flProtect)
{
#ifdef SP
	//printf("VirtualAlloc Called...\n");
#endif
	LPVOID ret = VirtualAllocNext(lpAddress, dwSize, flAllocationType, flProtect);
	return ret;
}

HANDLE WINAPI HeapCreateCallback(DWORD  flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize)
{
#ifdef SP
	//printf("HeapCreate Called...\n");
#endif
	HANDLE ret = HeapCreateNext(flOptions, dwInitialSize, dwMaximumSize);
	return ret;
}

BOOL WINAPI WriteProcessMemoryCallback(HANDLE  hProcess, LPVOID  lpBaseAddress, LPCVOID lpBuffer, SIZE_T  nSize, SIZE_T  *lpNumberOfBytesWritten)
{
#ifdef SP
	//printf("WriteProcessMemory Called...\n");
#endif
	BOOL ret = WriteProcessMemoryNext(hProcess, lpBaseAddress, lpBuffer, nSize, lpNumberOfBytesWritten);
	return ret;
}

BOOL WINAPI VirtualProtectCallback(LPVOID lpAddress, SIZE_T dwSize, DWORD  flNewProtect, PDWORD lpflOldProtect)
{
#ifdef SP
	//printf("VirtualProtect Called...\n");
#endif


#ifdef _WIN64
	unsigned long long ret;
	BYTE call_op;
	BYTE call_op2;
	//get_ret64(&ret, &call_op);

	ret = (unsigned long long)_ReturnAddress();
	call_op = *((BYTE *)ret - 5);
	call_op2 = *((BYTE *)ret - 6);


#else
	DWORD ret;
	BYTE call_op;
	BYTE call_op2;
	DWORD _esp;

	__asm
	{
		mov eax, esp;
		mov _esp, eax
	}

	ret = (DWORD)_ReturnAddress();
	call_op = *((BYTE *)ret - 5);
	call_op2 = *((BYTE *)ret - 6);

#endif

	MEMORY_BASIC_INFORMATION mbi;
	VirtualQueryEx(GetCurrentProcess(), (LPCVOID)ret, &mbi, 0x1c);

	//printf(">> %d\n", bit);
	if ( call_op != 0xE8 && call_op2!=0xFF)
	{
		Detect_Func(1);
	}

	else if (mbi.Type == MEM_PRIVATE) // Heap Execution  << Stack aslr DEP ON
	{
		Detect_Func(2);
	}




	BOOL OriFunc_ret = VirtualProtectNext(lpAddress, dwSize, flNewProtect, lpflOldProtect);
	return OriFunc_ret;

}

BOOL WINAPI SetProcessDEPPolicyCallback(_In_ DWORD dwFlags)
{
#ifdef SP
	//printf("SetProcessDEPPolicy Called...\n");
#endif
	BOOL ret = SetProcessDEPPolicyNext(dwFlags);
	return ret;
}

