
#include <tchar.h>
#include <process.h>
#include <WinSock2.h>
#include <cstdio>
#include <WinInet.h>
#include <time.h>


#include "hook.h"
#include "main.h"

#ifdef __cplusplus
extern "C" {
#endif
#include <lua.h>
#include <lualib.h>
#include <lauxlib.h>
#ifdef __cplusplus
}
#endif

int OSver = 0;


//#pragma comment(lib,"Wininet.lib")


#pragma comment(lib,"ws2_32.lib")
//#pragma comment(lib,"libcurl_a.lib")
#pragma comment(lib, "wldap32.lib")


#pragma comment(lib, "lua53.lib")


//#pragma comment(lib, "cryptlib.lib")
//#pragma comment(lib, "VMProtectSDK32.lib")
//#pragma comment(lib,"SecureEngineSDK32.lib")
#pragma comment(lib,"iphlpapi.lib")



HMODULE g_hDLL = NULL;


lua_State *GL = NULL;


char ProgramDir[MAX_PATH];
char LogDir[MAX_PATH];

/*
int lua_rand(lua_State* L)
{
	int a = 0;
	int c = 0;
	lua_Integer b = 0;
	a = (int)luaL_checkinteger(L, 1);
	c = (int)luaL_checkinteger(L, 2);
	srand(time(NULL));

	b = rand() % (c - a + 1) + a;
	lua_pushinteger(L, b);
	
	return 1;
}

int lua_say(lua_State* L)
{
	char str[256] = { 0x00, };
	strcpy(str, (char *)luaL_checkstring(L, 1));


	return 0;
}
*/
int lua_showtext(lua_State* L)
{
	int color = 0;
	char str[256] = { 0x00, };

	strcpy(str, (char *)luaL_checkstring(L, 1));
	color = (int)luaL_checkinteger(L, 2);

	printf("str:%s color:%d\n", str, color);
	return 0;
}


unsigned WINAPI start_script(void *args)
{
	char tempdir[MAX_PATH] = { 0x00, };
	char dir[MAX_PATH] = { 0x00, };
	lua_State *L;
	L = luaL_newstate();
	if ((INT)L == 0 || (INT)L == -1)
		return 0;


	luaL_openlibs(L);
	lua_register(L, "showtext", lua_showtext);
	//lua_register(L, "say", lua_say);
	//lua_register(L, "rand", lua_rand);



	GL = lua_newthread(L);


	//strcpy(tempdir, scriptdir); 중요함

	strcat(tempdir, (char *)args);
	//luaL_dofile(L, tempdir);
	if (luaL_dofile(L, tempdir))
	{
		//showtext((char *)lua_tostring(L, -1), 0x13);
	}

	//lua_close(GL);
	GL = 0;
	lua_close(L);

	return 0;
}
int WriteLog(wchar_t content)
{
	FILE *fp = fopen(LogDir, "a+");
	
	fwrite((const void *)content, 4, 1, fp);
	
	return 0;

}

int What_is_this_OS()
{
	OSVERSIONINFO osvi;
	ZeroMemory(&osvi, sizeof(OSVERSIONINFO));
	osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	GetVersionEx(&osvi);
	//Windows 7 WIndows 8 6.2

	if (osvi.dwMajorVersion == 6)
	{
		if (osvi.dwMinorVersion==1)
		{
			return 1;
		}
		else if (osvi.dwMinorVersion == 2)
		{
			return 2;
		}
	}
	else if (osvi.dwMajorVersion == 10 && osvi.dwMinorVersion == 0)
	{
		return 3;
	}



	//Windows XP    / 5
	//Windows Vista / 6 0
	//Windows 7     / 6 1
	//Windows 10    / 10 0

	
	return 0;
}
unsigned WINAPI start_hooks(void *args)
{
	char FILE_NAME[MAX_PATH];
	char PROCESS_NAME[MAX_PATH];
	//UnHookFunction("ws2_32.dll", "send", sendhook);
	//int result = send(s, buf, len, flags);
	//HookFunction("Wininet.dll", "InternetCrackUrlW", (LPVOID*)nInternetCrackUrlW, InternetCrackUrlW_hook);
	

	OSver = What_is_this_OS();

	if (OSver == 0)
	{
		return 1;
	}
	
	
	{
		HKEY    hKey;
		DWORD   data_type;
		DWORD   data_size;
		
		if (!RegOpenKeyExW(HKEY_CURRENT_USER, L"Software\\SaintSecurity\\MSX", 0, KEY_QUERY_VALUE, &hKey))
		{
			memset(ProgramDir, 0, sizeof(ProgramDir));
			data_size = sizeof(ProgramDir);
			RegQueryValueExA(hKey,                  
				"ProgramDir",                   
				0,                                    // 옵션 항상 0   
				&data_type,                           // 얻어진 데이터 타입  
				(BYTE*)ProgramDir,                  // 얻어진 데이터  
				(DWORD *)&data_size                  // 얻어진 데이터 크기   
			);
			RegCloseKey(hKey);
		}


	}
	sprintf(LogDir,"%s%s", ProgramDir, "\\Logs\\Logs.log"); //로그경로만들기





#ifdef _WIN64
	//HookFunction64("kernel32.dll", "CreateProcessA", (LPVOID*)nCreateProcessA, CreateProcessA64_hook);
	HookFunction64("kernel32.dll", "CreateProcessW", (LPVOID*)nCreateProcessW, CreateProcessW64_hook);
#else
	//HookFunction("kernel32.dll", "CreateProcessA", (LPVOID*)nCreateProcessA, CreateProcessA_hook);
	HookFunction("kernel32.dll", "CreateProcessW", (LPVOID*)nCreateProcessW, CreateProcessW_hook);

#endif
	GetModuleFileNameA(0, PROCESS_NAME, MAX_PATH);
	
	for (int i = strlen(PROCESS_NAME); i > 0; i--)
	{
		if (PROCESS_NAME[i] == '\\')
		{
			strcpy(PROCESS_NAME, PROCESS_NAME + i + 1);
			break;
		}
	}

	//printf("PROCESS_NAME : %s\n", PROCESS_NAME);


	GetModuleFileNameA(g_hDLL, FILE_NAME, MAX_PATH);
	//printf("DLL_PATH : %s\n",FILE_NAME);


	
	

	return 0;
}


BOOL APIENTRY DllMain(HMODULE hModul, DWORD ul_reason_for_ca, LPVOID lpReserve)
{
	FILE* out = 0;
	WSADATA wsadata;
	switch (ul_reason_for_ca)
	{
	case DLL_PROCESS_ATTACH:
		g_hDLL = hModul;

		DisableThreadLibraryCalls(hModul);

		AllocConsole();
		freopen_s(&out, "CON", "w", stdout);
		SetConsoleTitleA("Console");

		WSAStartup(MAKEWORD(2, 2), &wsadata);

		_beginthreadex(NULL, NULL, start_hooks, NULL, NULL, NULL);
		
		break;
	case DLL_THREAD_ATTACH:

		break;
	case DLL_THREAD_DETACH:
		break;
	case DLL_PROCESS_DETACH:
		break;
	}
	return TRUE;
}