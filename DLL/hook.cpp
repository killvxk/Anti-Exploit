#include <Windows.h>
#include <stdio.h>
#include "wintoastlib.h"

using namespace WinToastLib;
BYTE CreateProcessW_hook[6];
BYTE CreateProcessA_hook[6];

BYTE CreateProcessW64_hook[14];
BYTE CreateProcessA64_hook[14];

BYTE jmp[6] = { 0xe9, 0x00, 0x00, 0x00, 0x00, 0xc3 };
BYTE jmp64[14] = { 0x68, 0x00, 0x00, 0x00, 0x00, 0xc7, 0x44, 0x24, 0x04 , 0x00,0x00,0x00,0x00,0xC3 };


BOOL MemoryEdit(VOID *lpMem, VOID *lpSrc, DWORD len)
{
	DWORD lpflOldProtect, flNewProtect = PAGE_READWRITE;
	unsigned char * pDst = (unsigned char *)lpMem,
		*pSrc = (unsigned char *)lpSrc;
	if (VirtualProtect(lpMem, len, flNewProtect, &lpflOldProtect))
	{
		while (len-- > 0) *pDst++ = *pSrc++;
		return(0);
	}
	return(1);
}

DWORD HookFunction(LPCSTR lpModule, LPCSTR lpFuncName, LPVOID lpFunction, unsigned char *lpBackup)
{
	DWORD dwAddr = (DWORD)GetProcAddress(GetModuleHandleA(lpModule), lpFuncName);
	ReadProcessMemory(GetCurrentProcess(), (LPVOID)dwAddr, lpBackup, 6, 0);

	DWORD dwCalc = ((DWORD)lpFunction - dwAddr - 5);
	memcpy(&jmp[1], &dwCalc, 4);
	WriteProcessMemory(GetCurrentProcess(), (LPVOID)dwAddr, jmp, 6, 0);
	return dwAddr;
}

BOOL UnHookFunction(LPCSTR lpModule, LPCSTR lpFuncName, unsigned char *lpBackup)
{
	DWORD dwAddr = (DWORD)GetProcAddress(GetModuleHandleA(lpModule), lpFuncName);
	if (WriteProcessMemory(GetCurrentProcess(), (LPVOID)dwAddr, lpBackup, 6, 0))
		return TRUE;
	return FALSE;
}

DWORD HookFunction64(LPCSTR lpModule, LPCSTR lpFuncName, LPVOID lpFunction, unsigned char *lpBackup)
{
	DWORD64 dwAddr = (DWORD64)GetProcAddress(GetModuleHandleA(lpModule), lpFuncName);
	ReadProcessMemory(GetCurrentProcess(), (LPVOID)dwAddr, lpBackup, 14, 0);



	DWORD dwCalc = ((DWORD64)lpFunction) & 0x00000000FFFFFFFF;
	memcpy(&jmp64[1], &dwCalc, 4);
	dwCalc = ((((DWORD64)lpFunction) & 0xFFFFFFFF00000000) >> 32);
	memcpy(&jmp64[9], &dwCalc, 4);

	WriteProcessMemory(GetCurrentProcess(), (LPVOID)dwAddr, jmp64, 14, 0);
	return dwAddr;
}

BOOL UnHookFunction64(LPCSTR lpModule, LPCSTR lpFuncName, unsigned char *lpBackup)
{
	DWORD64 dwAddr = (DWORD64)GetProcAddress(GetModuleHandleA(lpModule), lpFuncName);
	if (WriteProcessMemory(GetCurrentProcess(), (LPVOID)dwAddr, lpBackup, 14, 0))
		return TRUE;
	return FALSE;
}


bool bCompare(const BYTE* pData, const BYTE* bMask, const char* szMask)
{
	for (; *szMask; ++szMask, ++pData, ++bMask)
		if (*szMask == 'x' && *pData != *bMask) return 0;
	return (*szMask) == NULL;
}


BYTE * FindPattern(DWORD dwAddress, DWORD dwLen, BYTE *bMask, char * szMask)
{
	for (DWORD i = 0; i<dwLen; i++)
		if (bCompare((BYTE*)(dwAddress + i), bMask, szMask)) return (BYTE *)(dwAddress + i);
	return 0;
}



class CustomHandler : public IWinToastHandler {
public:
	void toastActivated() const {
		std::wcout << L"The user clicked in this toast" << std::endl;
	}

	void toastActivated(int actionIndex) const {
		std::wcout << L"The user clicked on button #" << actionIndex << L" in this toast" << std::endl;
	}

	void toastFailed() const {
		std::wcout << L"Error showing current toast" << std::endl;
	}
	void toastDismissed(WinToastDismissalReason state) const {
		switch (state) {
		case UserCanceled:
			std::wcout << L"The user dismissed this toast" << std::endl;
			break;
		case ApplicationHidden:
			std::wcout << L"The application hid the toast using ToastNotifier.hide()" << std::endl;
			break;
		case TimedOut:
			std::wcout << L"The toast has timed out" << std::endl;
			break;
		default:
			std::wcout << L"Toast not activated" << std::endl;
			break;
		}
	}
};

BOOL WINAPI nCreateProcessW(LPCWSTR lpApplicationName, LPWSTR lpCommandLine, LPSECURITY_ATTRIBUTES lpProcessAttributes,
	LPSECURITY_ATTRIBUTES lpThreadAttributes, BOOL bInheritHandles, DWORD dwCreationFlags, LPVOID lpEnvironment,
	LPCWSTR lpCurrentDirectory, LPSTARTUPINFOW lpStartupInfo, LPPROCESS_INFORMATION lpProcessInformation)
{
#ifdef _WIN64
	UnHookFunction64("kernel32.dll", "CreateProcessW", CreateProcessW64_hook);
#else
	UnHookFunction("kernel32.dll", "CreateProcessW", CreateProcessW_hook);
#endif

	//wprintf(L"RUN: %s", lpApplicationName);


	//Sleep(5000);

	//BOOL ret = CreateProcessW(lpApplicationName, lpCommandLine, lpProcessAttributes, lpThreadAttributes, bInheritHandles, dwCreationFlags, lpEnvironment, lpCurrentDirectory, lpStartupInfo, lpProcessInformation);
	BOOL ret = -1;



	if (!WinToast::isCompatible()) {
		std::wcout << L"Error, your system in not supported!" << std::endl;
	}
	WinToast::instance()->setAppName(L"stscae");
	WinToast::instance()->setAppUserModelId(
		WinToast::configureAUMI(L"saintsecurity", L"msx", L"stscae", L"1"));

	if (!WinToast::instance()->initialize()) {
		std::wcout << L"Error, could not initialize the lib!" << std::endl;
	}


	WinToastTemplate templ = WinToastTemplate(WinToastTemplate::Text01);

	templ.setTextField(L"[*]RUN PROCESS GUARD", WinToastTemplate::FirstLine);


	if (!WinToast::instance()->showToast(templ, new CustomHandler)) {
		std::wcout << L"Error: Could not launch your toast notification!" << std::endl;
	}



#ifdef _WIN64
	HookFunction64("kernel32.dll", "CreateProcessW", (LPVOID*)nCreateProcessW, CreateProcessW64_hook);
#else
	HookFunction("kernel32.dll", "CreateProcessW", (LPVOID*)nCreateProcessW, CreateProcessW_hook);
#endif

	return ret;
}