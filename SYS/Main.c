#pragma warning( disable: 4703)

#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <windef.h>
/*
#include <ntifs.h>           /// IfsKit\Inc
#include <ntddk.h>           /// Inc
#include <wdf.h>             /// Inc\WDF\KMDF\1.9
#include <ndis.h>            /// Inc
#include <fwpmk.h>           /// Inc
#include <fwpsk.h>           /// Inc
#include <netioddk.h>        /// Inc
#include <ntintsafe.h>       /// Inc
#include <ntstrsafe.h>       /// Inc
#include <stdlib.h>          /// SDK\Inc\CRT
*/


//http://www.cnblogs.com/aliflycoris/p/5468175.html
#include "util.h"
#include "Main.h"

#include "ObCallBack.h"
/*
typedef struct _IMAGE_NT_HEADERS {
DWORD                 Signature;
IMAGE_FILE_HEADER     FileHeader;
IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;
*/

wchar_t DLLBuffer[1024];
ULONG ApcStateOffset;
extern NTSTATUS ZwQuerySystemInformation(ULONG InfoClass, PVOID Buffer, ULONG Length, PULONG ReturnLength);

typedef struct _SYSTEM_THREAD_INFORMATION
{
	LARGE_INTEGER KernelTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER CreateTime;
	ULONG WaitTime;
	PVOID StartAddress;
	CLIENT_ID ClientId;
	KPRIORITY Priority;
	LONG BasePriority;
	ULONG ContextSwitches;
	ULONG ThreadState;
	KWAIT_REASON WaitReason;
}SYSTEM_THREAD_INFORMATION, *PSYSTEM_THREAD_INFORMATION;

typedef struct _SYSTEM_PROCESS_INFO
{
	ULONG NextEntryOffset;
	ULONG NumberOfThreads;
	LARGE_INTEGER WorkingSetPrivateSize;
	ULONG HardFaultCount;
	ULONG NumberOfThreadsHighWatermark;
	ULONGLONG CycleTime;
	LARGE_INTEGER CreateTime;
	LARGE_INTEGER UserTime;
	LARGE_INTEGER KernelTime;
	UNICODE_STRING ImageName;
	KPRIORITY BasePriority;
	HANDLE UniqueProcessId;
	HANDLE InheritedFromUniqueProcessId;
	ULONG HandleCount;
	ULONG SessionId;
	ULONG_PTR UniqueProcessKey;
	SIZE_T PeakVirtualSize;
	SIZE_T VirtualSize;
	ULONG PageFaultCount;
	SIZE_T PeakWorkingSetSize;
	SIZE_T WorkingSetSize;
	SIZE_T QuotaPeakPagedPoolUsage;
	SIZE_T QuotaPagedPoolUsage;
	SIZE_T QuotaPeakNonPagedPoolUsage;
	SIZE_T QuotaNonPagedPoolUsage;
	SIZE_T PagefileUsage;
	SIZE_T PeakPagefileUsage;
	SIZE_T PrivatePageCount;
	LARGE_INTEGER ReadOperationCount;
	LARGE_INTEGER WriteOperationCount;
	LARGE_INTEGER OtherOperationCount;
	LARGE_INTEGER ReadTransferCount;
	LARGE_INTEGER WriteTransferCount;
	LARGE_INTEGER OtherTransferCount;
	SYSTEM_THREAD_INFORMATION Threads[1];
}SYSTEM_PROCESS_INFO, *PSYSTEM_PROCESS_INFO;


typedef struct _KINJECT
{
	UNICODE_STRING DllName;
	wchar_t Buffer[1024];
	PLDR_LOAD_DLL LdrLoadDll;
	PVOID DllBase;
	ULONG Executed;
}KINJECT, *PKINJECT;
typedef enum _KAPC_ENVIRONMENT
{
	OriginalApcEnvironment,
	AttachedApcEnvironment,
	CurrentApcEnvironment,
	InsertApcEnvironment
}KAPC_ENVIRONMENT, *PKAPC_ENVIRONMENT;

typedef VOID(NTAPI *PKNORMAL_ROUTINE)(
	PVOID NormalContext,
	PVOID SystemArgument1,
	PVOID SystemArgument2
	);

typedef VOID KKERNEL_ROUTINE(
	PRKAPC Apc,
	PKNORMAL_ROUTINE *NormalRoutine,
	PVOID *NormalContext,
	PVOID *SystemArgument1,
	PVOID *SystemArgument2
);

typedef KKERNEL_ROUTINE(NTAPI *PKKERNEL_ROUTINE);

typedef VOID(NTAPI *PKRUNDOWN_ROUTINE)(
	PRKAPC Apc
	);

extern void KeInitializeApc(
	PRKAPC Apc,
	PRKTHREAD Thread,
	KAPC_ENVIRONMENT Environment,
	PKKERNEL_ROUTINE KernelRoutine,
	PKRUNDOWN_ROUTINE RundownRoutine,
	PKNORMAL_ROUTINE NormalRoutine,
	KPROCESSOR_MODE ProcessorMode,
	PVOID NormalContext
);

extern BOOLEAN KeInsertQueueApc(
	PRKAPC Apc,
	PVOID SystemArgument1,
	PVOID SystemArgument2,
	KPRIORITY Increment
);


UNICODE_STRING g_uNtdll = RTL_CONSTANT_STRING(L"ntdll.dll");

UNICODE_STRING linkNameUnicodeString;
UNICODE_STRING deviceNameUnicodeString;

UNICODE_STRING ProcessImageName;

struct protect_process
{
	int flag;
	char name[100];
} pp[101];



static BOOL	EqualModuleName(PUNICODE_STRING ModuleName, PUNICODE_STRING OtherName)
{
	BOOL Ret = FALSE;

	if (ModuleName && (ModuleName->Length >= OtherName->Length))
	{
		UNICODE_STRING	ShortName;
		ShortName.Length = OtherName->Length;
		ShortName.MaximumLength = OtherName->Length;
		ShortName.Buffer = (PWSTR)((PCHAR)ModuleName->Buffer + ModuleName->Length - ShortName.Length);
		Ret = (BOOL)RtlEqualUnicodeString(&ShortName, OtherName, TRUE);
	}
	return(Ret);
}

NTSTATUS DefaultPass(PDEVICE_OBJECT DeviceObject, PIRP pIrp)
{
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS MyControl(PDEVICE_OBJECT DeviceObject, PIRP pIrp)
{
	pIrp->IoStatus.Status = STATUS_SUCCESS;

	NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
	PIO_STACK_LOCATION IrpSp;
	ULONG FunctionCode;
	IrpSp = IoGetCurrentIrpStackLocation(pIrp);
	FunctionCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
	//DbgPrint("code=%x",FunctionCode);
	switch (FunctionCode)
	{
	case IOCTL_InitDriver:
		ntStatus = STATUS_SUCCESS;
		//__writecr0(__readcr0() & ~0x10000);

		wcscpy(DLLBuffer, pIrp->AssociatedIrp.SystemBuffer);

		for (int i = 0; i < 100; i++)
		{
			pp[i].flag = 0;      
		}

		//Target Process Clean
		DbgPrint("Already Load Driver...");
		break;

	

	case IOCTL_Change_Target:
		ntStatus = STATUS_SUCCESS;

		//__writecr0(__readcr0() & ~0x10000);
		/*
		struct input
		{
			char processname[64];
		} *pinp, inp;
		*/
		char *pinp;

		pinp = pIrp->AssociatedIrp.SystemBuffer;
		
		for (int i = 0; i < 100; i++)
		{
			if (pp[i].flag == 0)
			{
				strncpy(pp[i].name, pinp,100);
				pp[i].flag = 1;			
				break;
			}
		}

		//__writecr0(__readcr0() | 0x10000);
		break;


	case IOCTL_Clean_Target:
		ntStatus = STATUS_SUCCESS;
		for (int i = 0; i < 100; i++)
		{
			pp[i].flag = 0;
		}
		break;

	default:

		ntStatus = STATUS_SUCCESS;
		break;
	}



	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;


	return ntStatus;
}



PVOID KernelGetProcAddress(PVOID pModuleBase)
{
	PVOID pFunctionAddress = 0;

	if (!pModuleBase)
	{
		DbgPrint("failed! wrong pModuleBase or pFunctionName !\n");
		return 0;
	}
	__try
	{
		DbgPrint("KernelGetProcAddress searching... %llx\n", pModuleBase);

		PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pModuleBase;

		if (pDos->e_magic != 0x5A4D)
		{
			DbgPrint("failed! pDos != IMAGE_DOS_SIGNATURE: %d \n", pDos->e_magic);
			return 0;
		}
		PIMAGE_NT_HEADERS64 pNt = (PIMAGE_NT_HEADERS64)((BYTE*)pModuleBase + pDos->e_lfanew);

		if (pNt->Signature != 0x4550)
		{
			DbgPrint("failed! pNt != IMAGE_NT_SIGNATURE \n");
			return 0;
		}

		//DbgPrint("pNt done! %llx\n",pNt);

		PIMAGE_EXPORT_DIRECTORY pExpDir = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)pModuleBase + pNt->OptionalHeader.DataDirectory[0].VirtualAddress);

		//DbgPrint("pExpDir done! %llx\n", pNt->OptionalHeader.DataDirectory[0].VirtualAddress);

		ULONG *AddressOfFunctionsArray = (ULONG*)((BYTE*)pModuleBase + pExpDir->AddressOfFunctions);
		ULONG *AddressOfNamesArray = (ULONG*)((BYTE*)pModuleBase + pExpDir->AddressOfNames);
		USHORT *AddressOfNameOrdinalsArray = (USHORT*)((BYTE*)pModuleBase + pExpDir->AddressOfNameOrdinals);

		//DbgPrint("AddressOfFunctionsArray: [%02llX] \n", AddressOfFunctionsArray);
		//DbgPrint("AddressOfNamesArray: [%02llX] \n", AddressOfNamesArray);
		//DbgPrint("AddressOfNameOrdinalsArray: [%02llX] \n", AddressOfNameOrdinalsArray);
		
		for (ULONG i = 0; i < pExpDir->NumberOfNames; i++)//NumberOfFunctions
		{
			if (!strcmp((ULONGLONG *)((char*)pModuleBase + AddressOfNamesArray[i]), "LdrLoadDll"))
			{	
				LdrLoadDll = (BYTE*)pModuleBase + AddressOfFunctionsArray[AddressOfNameOrdinalsArray[i]];
			}
			else if (!strcmp((ULONGLONG *)((char*)pModuleBase + AddressOfNamesArray[i]), "ZwReadVirtualMemory"))
			{
				ZwReadVirtualMemory = (BYTE*)pModuleBase + AddressOfFunctionsArray[AddressOfNameOrdinalsArray[i]];
				//DbgPrint("found %s  %llx!\n", "ZwReadVirtualMemory", (BYTE*)pModuleBase + AddressOfFunctionsArray[AddressOfNameOrdinalsArray[i]]);

			}
			else if (!strcmp((ULONGLONG *)((char*)pModuleBase + AddressOfNamesArray[i]), "ZwWriteVirtualMemory"))
			{
				ZwWriteVirtualMemory = (BYTE*)pModuleBase + AddressOfFunctionsArray[AddressOfNameOrdinalsArray[i]];
				//DbgPrint("found %s  %llx!\n", "ZwWriteVirtualMemory", (BYTE*)pModuleBase + AddressOfFunctionsArray[AddressOfNameOrdinalsArray[i]]);
			}
		}

		//ZwFreeVirtualMemory(NtCurrentProcess(), (PVOID*)&mem, &size, MEM_RELEASE);


	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint("EXCEPTION_EXECUTE_HANDLER [0x%x] !!! \n", _exception_code());
		pFunctionAddress = 0;
	}

	return pFunctionAddress;
}
void NTAPI KernelRoutine(PKAPC apc, PKNORMAL_ROUTINE* NormalRoutine, PVOID* NormalContext, PVOID* SystemArgument1, PVOID* SystemArgument2)
{
	ExFreePool(apc);
}

void NTAPI InjectDllApc(PVOID NormalContext, PVOID SystemArgument1, PVOID SystemArgument2)
{
	PKINJECT inject = (PKINJECT)NormalContext;

	inject->LdrLoadDll(NULL, NULL, &inject->DllName, &inject->DllBase);
	inject->Executed = TRUE;
}



VOID _stdcall MyLoadImageNotifyRoutine(PUNICODE_STRING	FullImageName, HANDLE	ProcessId, PIMAGE_INFO ImageInfo)

{
	//(ULONGLONG)BkGetFunctionAddress(NtdllBase, "LdrLoadDll")))

	
	if (EqualModuleName(FullImageName, &g_uNtdll))
	{
		if (!IsWow64Process(ProcessId))
		{
			
			char *cpname = GetProcessNameFromPid(ProcessId);


			int RoutineFlag = 0;

			RoutineFlag = 0;	
			for (int i = 0; i < 100; i++)
			{
				if (pp[i].flag == 1)
				{
					if (strncmp(pp[i].name, cpname,100) == 0)
					{
						RoutineFlag = 1;
						break;
					}
				}
			}
			if (RoutineFlag==1)
			{
				PEPROCESS Process;
				PKTHREAD Thread;
				PKAPC_STATE ApcState;
				PKAPC apc;
				PVOID buffer;
				PSYSTEM_PROCESS_INFO pSpi;
				LARGE_INTEGER delay;

				PsLookupProcessByProcessId(ProcessId, &Process);


				//DbgPrint("64 Process:%s  Path:%wZ ImageBase:%llx", GetProcessNameFromPid(ProcessId), FullImageName, ImageInfo->ImageBase);

				apc = (PKAPC)ExAllocatePool(NonPagedPool, sizeof(KAPC));



				KeAttachProcess(Process);

				__try {
					size_t size = 0x1000;
					PKINJECT mem = 0;
					HANDLE hProcessHandle = NULL;

					KernelGetProcAddress(ImageInfo->ImageBase);

					ObOpenObjectByPointer(Process, 0, NULL, 0, 0, KernelMode, &hProcessHandle);
					
					if (!NT_SUCCESS(ZwAllocateVirtualMemory(hProcessHandle, (PVOID *)&mem, 0, &size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)))
					{
						DbgPrint("Allocate Error!");
						ExFreePool(apc);
						goto exit;
					}
					else {
						DbgPrint("Allocate Memory! %llx\n", mem);
					}


					mem->LdrLoadDll = LdrLoadDll;
					wcscpy(mem->Buffer, DLLBuffer);

					

					RtlInitUnicodeString(&mem->DllName, mem->Buffer);


					mem->DllBase = 0;
					memcpy((PKINJECT)(mem + 1), InjectDllApc, (ULONG)KernelRoutine - (ULONG)InjectDllApc);
					//DbgPrint("APC code address: %llx\n", (PKINJECT)(mem + 1));

					if (!NT_SUCCESS(PsLookupThreadByThreadId(PsGetCurrentThreadId(), &Thread)))
					{
						DbgPrint("Error: Unable to reference the target thread.");
						ExFreePool(apc);
						return FALSE;
					}

					KeInitializeApc(apc, KeGetCurrentThread(), OriginalApcEnvironment, KernelRoutine, NULL, (PKNORMAL_ROUTINE)((PKINJECT)mem + 1), UserMode, mem);
					KeInsertQueueApc(apc, NULL, NULL, IO_NO_INCREMENT);

					/*
					delay.QuadPart = -1 * 10000000;

					while (!mem->Executed)
					{
					DbgPrint("flag: %lu", mem->Executed);
					KeDelayExecutionThread(KernelMode, FALSE, &delay); // Wait for the injection to complete
					}

					DbgPrint("DLL injected at %#x", mem->DllBase);
					*/
					//ZwFreeVirtualMemory(NtCurrentProcess(), (PVOID *)&mem, &size, MEM_RELEASE);

				exit:;
				}
				__except (EXCEPTION_EXECUTE_HANDLER)
				{
					DbgPrint("EXCEPTION_EXECUTE_HANDLER [0x%x] !!! \n", _exception_code());
				}


				KeDetachProcess();


			}
		}
	}
}









NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegisterPath)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;
	PEPROCESS Process;
	PETHREAD Thread;
	PULONG ptr;

	PDEVICE_OBJECT pMyDevice;

	DbgPrint("___[Empire Kernel Load]___");


	RtlInitUnicodeString(&deviceNameUnicodeString, L"\\Device\\Empire");
	Status = IoCreateDevice(DriverObject, 4, &deviceNameUnicodeString, FILE_DEVICE_UNKNOWN, 0, TRUE, &pMyDevice);
	if (!NT_SUCCESS(Status))
	{
		DbgPrint("Failed to create the device!\n");
		return Status;
	}

	RtlInitUnicodeString(&linkNameUnicodeString, L"\\DosDevices\\Empire");
	Status = IoCreateSymbolicLink(&linkNameUnicodeString, &deviceNameUnicodeString);
	if (!NT_SUCCESS(Status))
	{
		DbgPrint("Failed to create the symlink\n");
		return Status;
	}


#ifdef _WIN64  
	PLDR_DATA_TABLE_ENTRY64 ldr;
	ldr = (PLDR_DATA_TABLE_ENTRY64)
		DriverObject->DriverSection;
#else  
	PLDR_DATA_TABLE_ENTRY ldr;
	ldr = (PLDR_DATA_TABLE_ENTRY)
		DriverObject->DriverSection;
#endif  
	ldr->Flags |= 0x20;


	//ProtectFileByObRegisterCallbacks(); //x64?
	for (int nIndex = 0; nIndex < IRP_MJ_MAXIMUM_FUNCTION; nIndex++)
	{
		DriverObject->MajorFunction[nIndex] = DefaultPass;

	}

	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MyControl;



	if (NULL == ZwQueryInformationProcess) {

		UNICODE_STRING routineName;

		RtlInitUnicodeString(&routineName, L"ZwQueryInformationProcess");

		ZwQueryInformationProcess =
			(QUERY_INFO_PROCESS)MmGetSystemRoutineAddress(&routineName);

		if (NULL == ZwQueryInformationProcess) {
			DbgPrint("Cannot resolve ZwQueryInformationProcess\n");
		}
	}



	Status = PsSetLoadImageNotifyRoutine(&MyLoadImageNotifyRoutine);




	DriverObject->DriverUnload = UnLoadDriver;
	Status = STATUS_SUCCESS;

	return Status;
}





NTSTATUS UnLoadDriver(PDRIVER_OBJECT DriverObject)
{

	NTSTATUS Status = STATUS_SUCCESS;
	DbgPrint("___[Empire Kernel Unload Success!]___");
	IoDeleteSymbolicLink(&linkNameUnicodeString);
	IoDeleteDevice(DriverObject->DeviceObject);

	PsRemoveLoadImageNotifyRoutine(&MyLoadImageNotifyRoutine);


Exit0:
	return Status;
}
