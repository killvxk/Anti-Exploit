#pragma warning( disable: 4703)

#include <ntifs.h>
#include <ntddk.h>
#include <ntimage.h>
#include <windef.h>
/*
#include <ntifs.h>           /// IfsKit\Inc
#include <ntddk.h>           /// Inc
#include <wdf.h>             /// Inc\WDF\KMDF\1.9
#include <ndis.h>            /// Inc
#include <fwpmk.h>           /// Inc
#include <fwpsk.h>           /// Inc
#include <netioddk.h>        /// Inc
#include <ntintsafe.h>       /// Inc
#include <ntstrsafe.h>       /// Inc
#include <stdlib.h>          /// SDK\Inc\CRT
*/


//http://www.cnblogs.com/aliflycoris/p/5468175.html

#include "Main.h"
/*
typedef struct _IMAGE_NT_HEADERS {
	DWORD                 Signature;
	IMAGE_FILE_HEADER     FileHeader;
	IMAGE_OPTIONAL_HEADER OptionalHeader;
} IMAGE_NT_HEADERS, *PIMAGE_NT_HEADERS;
*/













UNICODE_STRING g_uNtdll = RTL_CONSTANT_STRING(L"ntdll.dll");


PVOID  CallBackHandle = NULL;



UNICODE_STRING linkNameUnicodeString;
UNICODE_STRING deviceNameUnicodeString;

UNICODE_STRING ProcessImageName;


static BOOL	EqualModuleName(PUNICODE_STRING ModuleName, PUNICODE_STRING OtherName)
{
	BOOL Ret = FALSE;

	if (ModuleName && (ModuleName->Length >= OtherName->Length))
	{
		UNICODE_STRING	ShortName;
		ShortName.Length = OtherName->Length;
		ShortName.MaximumLength = OtherName->Length;
		ShortName.Buffer = (PWSTR)((PCHAR)ModuleName->Buffer + ModuleName->Length - ShortName.Length);
		Ret = (BOOL)RtlEqualUnicodeString(&ShortName, OtherName, TRUE);
	}
	return(Ret);
}

NTSTATUS DefaultPass(PDEVICE_OBJECT DeviceObject, PIRP pIrp)
{
	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;
}

NTSTATUS MyControl(PDEVICE_OBJECT DeviceObject, PIRP pIrp)
{
	pIrp->IoStatus.Status = STATUS_SUCCESS;

	NTSTATUS ntStatus = STATUS_UNSUCCESSFUL;
	PIO_STACK_LOCATION IrpSp;
	ULONG FunctionCode;
	IrpSp = IoGetCurrentIrpStackLocation(pIrp);
	FunctionCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
	//DbgPrint("code=%x",FunctionCode);
	switch (FunctionCode)
	{
	case IOCTL_READ_MEMORY:

		ntStatus = STATUS_SUCCESS;
		break;



	case IOCTL_WRITE_MEMORY:
		

		ntStatus = STATUS_SUCCESS;
		break;


	case IOCTL_OPEN_PROCESS:
	
		
		break;
	
	default:

		ntStatus = STATUS_SUCCESS;
		break;
	}



	pIrp->IoStatus.Status = STATUS_SUCCESS;
	IoCompleteRequest(pIrp, IO_NO_INCREMENT);
	return STATUS_SUCCESS;

	
	return ntStatus;
}

CHAR * GetProcessNameFromPid(HANDLE pid)
{
	PEPROCESS Process;
	if (PsLookupProcessByProcessId(pid, &Process) == STATUS_INVALID_PARAMETER)
	{
		return "pid???";
	}
	//return L"ASDF";
	return (CHAR*)PsGetProcessImageFileName(Process);
}

static	HANDLE	OpenProcessById(HANDLE ProcessId, ACCESS_MASK AccessMask)
{
	HANDLE		hProcess;
	CLIENT_ID	ClientId = { 0 };
	OBJECT_ATTRIBUTES	oa = { 0 };

	ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

	ClientId.UniqueProcess = ProcessId;
	InitializeObjectAttributes(&oa, NULL, OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, 0, NULL);

	if (!(NT_SUCCESS(ZwOpenProcess(&hProcess, AccessMask, &oa, &ClientId))))
		hProcess = NULL;

	return(hProcess);
}

static	BOOL	IsWow64Process(HANDLE	ProcessId)
{
	BOOL	Ret = FALSE;
	HANDLE	hProcess = OpenProcessById(ProcessId, GENERIC_READ);
	PVOID	ProcessWow64Info = NULL;

	if (hProcess)
	{
		NTSTATUS ntStatus = ZwQueryInformationProcess(hProcess, ProcessWow64Information, &ProcessWow64Info, sizeof(PVOID), NULL);
	
		if (NT_SUCCESS(ntStatus) && ProcessWow64Info != NULL)
			Ret = TRUE;

		ZwClose(hProcess);
	}	// if (hProcess)

	return(Ret);
}

PVOID KernelGetProcAddress(PVOID pModuleBase, PCHAR pFunctionName)
{
	PVOID pFunctionAddress = 0;

	if (!pModuleBase || !pFunctionName)
	{
		DbgPrint("failed! wrong pModuleBase or pFunctionName !\n");
		return 0;
	}

	__try
	{
		DbgPrint("KernelGetProcAddress searching %s... %llx\n", pFunctionName, pModuleBase);

		PIMAGE_DOS_HEADER pDos = (PIMAGE_DOS_HEADER)pModuleBase;

		if (pDos->e_magic != 0x5A4D)
		{
			DbgPrint("failed! pDos != IMAGE_DOS_SIGNATURE: %d \n", pDos->e_magic);
			return 0;
		}

		//DbgPrint("pDos done! \n");
		//7ff85f5fc340
		PIMAGE_NT_HEADERS64 pNt = (PIMAGE_NT_HEADERS64)((BYTE*)pModuleBase + pDos->e_lfanew);

		if (pNt->Signature != 0x4550)
		{
			DbgPrint("failed! pNt != IMAGE_NT_SIGNATURE \n");
			return 0;
		}

		//DbgPrint("pNt done! %llx\n",pNt);
		
		PIMAGE_EXPORT_DIRECTORY pExpDir = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)pModuleBase + pNt->OptionalHeader.DataDirectory[0].VirtualAddress);
		
		//DbgPrint("pExpDir done! %llx\n", pNt->OptionalHeader.DataDirectory[0].VirtualAddress);

		ULONG *AddressOfFunctionsArray = (ULONG*)((BYTE*)pModuleBase+pExpDir->AddressOfFunctions);
		ULONG *AddressOfNamesArray = (ULONG*)((BYTE*)pModuleBase+pExpDir->AddressOfNames);
		USHORT *AddressOfNameOrdinalsArray = (USHORT*)((BYTE*)pModuleBase+pExpDir->AddressOfNameOrdinals);
		
		//DbgPrint("AddressOfFunctionsArray: [%02llX] \n", AddressOfFunctionsArray);
		//DbgPrint("AddressOfNamesArray: [%02llX] \n", AddressOfNamesArray);
		//DbgPrint("AddressOfNameOrdinalsArray: [%02llX] \n", AddressOfNameOrdinalsArray);
		/*
		PKINJET mem;
		ULONG size;

		mem = NULL;
		size = 0x1000;
		if (!NT_SUCCESS(ZwAllocateVirtualMemory(NtCurrentProcess(), (PVOID*)&mem, 0, &size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)))
		{
			DbgPrint("ERRRRRRRRRRRRRRRRRRRRRR");
			DbgPrint("ERRRRRRRRRRRRRRRRRRRRRR");
			DbgPrint("ERRRRRRRRRRRRRRRRRRRRRR");
			DbgPrint("ERRRRRRRRRRRRRRRRRRRRRR");
			DbgPrint("ERRRRRRRRRRRRRRRRRRRRRR");
			DbgPrint("ERRRRRRRRRRRRRRRRRRRRRR");
		}
		*/
		for (ULONG i = 0; i < pExpDir->NumberOfNames; i++)//NumberOfFunctions
		{
			//crashes here I gues.
			if (!strcmp((ULONGLONG *)((char*)pModuleBase + AddressOfNamesArray[i]), pFunctionName))
			{
				//mem->LdrLoadDll = (BYTE*)pModuleBase + AddressOfFunctionsArray[AddressOfNameOrdinalsArray[i]];

				DbgPrint("found %s  %llx!\n", pFunctionName, (BYTE*)pModuleBase + AddressOfFunctionsArray[AddressOfNameOrdinalsArray[i]]);
				
				

				return (BYTE*)pModuleBase + AddressOfFunctionsArray[AddressOfNameOrdinalsArray[i]];
				//mem->LdrLoadDll = 111;
				//RtlInitUnicodeString(&mem->DllName, L"C:\\Users\\Kang\\Documents\\Visual Studio 2015\\Projects\\MSX\\MSX\\stscae64.dll");
				
				/*
				ULONG flags = 8; //0x00000008 LOAD_WITH_ALTERED_SEARCH_PATH;
				HMODULE module=0;
				UNICODE_STRING dll;
				mem->flags = 8;
				
				mem->LdrLoadDll(NULL, &mem->flags,&mem->DllName, &mem->DllBase);
			    */
			   
				break;
			}
		}
		
		//ZwFreeVirtualMemory(NtCurrentProcess(), (PVOID*)&mem, &size, MEM_RELEASE);


	}
	__except (EXCEPTION_EXECUTE_HANDLER)
	{
		DbgPrint("EXCEPTION_EXECUTE_HANDLER [0x%x] !!! \n", _exception_code());
		pFunctionAddress = 0;
	}

	return pFunctionAddress;
}

VOID _stdcall MyLoadImageNotifyRoutine(	PUNICODE_STRING	FullImageName,	HANDLE	ProcessId,PIMAGE_INFO ImageInfo)

{
	//(ULONGLONG)BkGetFunctionAddress(NtdllBase, "LdrLoadDll")))
    
	if (EqualModuleName(FullImageName, &g_uNtdll))
	{
		if (IsWow64Process(ProcessId))
		{
			DbgPrint("32 Process:%s  Path:%wZ ImageBase:%llx",GetProcessNameFromPid(ProcessId), FullImageName, ImageInfo->ImageBase);
		}
		else
		{
			
			if (strcmp(GetProcessNameFromPid(ProcessId), "wscript.exe") == 0)
			{

				DbgPrint("64 Process:%s  Path:%wZ ImageBase:%llx", GetProcessNameFromPid(ProcessId), FullImageName, ImageInfo->ImageBase);



				

				PEPROCESS Process;
				PsLookupProcessByProcessId(ProcessId, &Process);
				KeAttachProcess(Process);


				
				PVOID ldr = KernelGetProcAddress(ImageInfo->ImageBase, "LdrLoadDll");
				
				
				
				__try {

					
					
					
					/*
					ULONG size = 4096;
					PKINJET mem=0;
					if (!NT_SUCCESS(ZwAllocateVirtualMemory(NtCurrentProcess(), (PVOID *)&mem, 0, &size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE)))
					{
						DbgPrint("ERRRRRRRRRRRRRRRRRRRRRR");
						DbgPrint("ERRRRRRRRRRRRRRRRRRRRRR");
						DbgPrint("ERRRRRRRRRRRRRRRRRRRRRR");
						DbgPrint("ERRRRRRRRRRRRRRRRRRRRRR");
						DbgPrint("ERRRRRRRRRRRRRRRRRRRRRR");
						DbgPrint("ERRRRRRRRRRRRRRRRRRRRRR");
						goto exit;
					}
					else {
						DbgPrint("Allocate Memory! %llx\n", mem);
					}
					//ZwWriteVirtualMemory(NtCurrentProcess(), mem, "ASDF", 4, 0);
					

					mem->flags = 8;
					mem->DllBase=0;
				
					
					RtlInitUnicodeString(&mem->DllName, L"C:\\Users\\Kang\\Documents\\Visual Studio 2015\\Projects\\MSX\\MSX\\stsc64.dll");
					RtlInitUnicodeString(&mem->DllName, L"kernel32.dll");

					//LdrLoadDll;
					
					mem->LdrLoadDll(NULL, &mem->flags, &mem->DllName, &mem->DllBase);

				


				// (NtCurrentProcess(), mem, "ASDF", 4, 0);
					/*
					((DWORD *)mem)[0] = 8;

					((DWORD *)mem)[1] = 0;
					
					UNICODE_STRING TempName;
					RtlInitUnicodeString(&TempName, L"C:\\Users\\Kang\\Documents\\Visual Studio 2015\\Projects\\MSX\\MSX\\stsc64.dll");
					
					((DWORD *)mem)[2] = &TempName;
					//LdrLoadDll(NULL, NULL, TempName, ImageInfo->ImageBase);
					//DbgPrint("AAAAAAAAAAA");
					LdrLoadDll(NULL, &(((DWORD *)mem)[0]), ((DWORD *)mem)[2], &(((DWORD *)mem)[1]));
					*/
					


					//ZwFreeVirtualMemory(NtCurrentProcess(), (PVOID*)&mem, &size, MEM_RELEASE);

				
				exit:;
				}
				__except (EXCEPTION_EXECUTE_HANDLER)
				{
					DbgPrint("EXCEPTION_EXECUTE_HANDLER [0x%x] !!! \n", _exception_code());
				}





				DbgPrint("Addr : %llx", ldr);


				



				KeDetachProcess();
				


				/*
				PEPROCESS Process;
				PsLookupProcessByProcessId(ProcessId, &Process);
				KeAttachProcess(Process);

				DbgPrint("64 Process:%s  Path:%wZ ImageBase:%llx", GetProcessNameFromPid(ProcessId), FullImageName, ImageInfo->ImageBase);

				UNICODE_STRING routineName;

				RtlInitUnicodeString(&routineName, L"LdrLoadDll");
				
				//DbgPrint("Addr : %llu" ,MmGetSystemRoutineAddress(&routineName));
				
				KeDetachProcess();
				*/
			}
		}
	}


	

	
}




NTSTATUS ProtectFileByObRegisterCallbacks()
{
	OB_CALLBACK_REGISTRATION  CallBackReg;

	OB_OPERATION_REGISTRATION OperationReg[2] = { { 0 },{ 0 } };
	NTSTATUS  Status;

	EnableObType(*IoFileObjectType);     
	memset(&CallBackReg, 0, sizeof(OB_CALLBACK_REGISTRATION));
	CallBackReg.Version = ObGetFilterVersion();
	CallBackReg.OperationRegistrationCount = 2;
	CallBackReg.RegistrationContext = NULL;
	RtlInitUnicodeString(&CallBackReg.Altitude, L"321000");



	//memset(OperationReg, 0, sizeof(OB_OPERATION_REGISTRATION)); 
	
	OperationReg[0].ObjectType = IoFileObjectType;
	OperationReg[0].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
	OperationReg[0].PreOperation = PreCallBack;
	
	
	OperationReg[1].ObjectType = PsProcessType;
	OperationReg[1].Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;
	OperationReg[1].PreOperation = preCall;//(POB_PRE_OPERATION_CALLBACK)
	

	CallBackReg.OperationRegistration = OperationReg;




	Status = ObRegisterCallbacks(&CallBackReg, &CallBackHandle);
	if (!NT_SUCCESS(Status))
	{
		Status = STATUS_UNSUCCESSFUL;
	}
	else
	{
		Status = STATUS_SUCCESS;
	}
	return Status;
}

OB_PREOP_CALLBACK_STATUS PreCallBack(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION OperationInformation)
{
	UNICODE_STRING uniDosName;
	UNICODE_STRING uniFilePath;
	PFILE_OBJECT FileObject = (PFILE_OBJECT)OperationInformation->Object;
	HANDLE CurrentProcessId = PsGetCurrentProcessId();
	if (OperationInformation->ObjectType != *IoFileObjectType)
	{
		return OB_PREOP_SUCCESS;
	}
	
	if (FileObject->FileName.Buffer == NULL ||
		!MmIsAddressValid(FileObject->FileName.Buffer) ||
		FileObject->DeviceObject == NULL ||
		!MmIsAddressValid(FileObject->DeviceObject))
	{
		return OB_PREOP_SUCCESS;
	}
	uniFilePath = GetFilePathByFileObject(FileObject);
	if (uniFilePath.Buffer == NULL || uniFilePath.Length == 0)
	{
		return OB_PREOP_SUCCESS;
	}
	if (wcsstr(uniFilePath.Buffer, L"C:\\Users\\Kang\\Desktop\\aaa.txt"))
	{
		DbgPrint("PID : %ld File : %wZ  %wZ\r\n", (ULONG64)CurrentProcessId, &uniDosName, &uniFilePath);


		if (FileObject->DeleteAccess == TRUE || FileObject->WriteAccess == TRUE)
		{
			if (OperationInformation->Operation == OB_OPERATION_HANDLE_CREATE)
			{
				
				OperationInformation->Parameters->CreateHandleInformation.DesiredAccess = 0;
			}
			if (OperationInformation->Operation == OB_OPERATION_HANDLE_DUPLICATE)
			{
				
				OperationInformation->Parameters->DuplicateHandleInformation.DesiredAccess = 0;
			}
			
		}
		
		//DbgPrint("%lu", FileObject->ReadAccess);
	}
	RtlVolumeDeviceToDosName(FileObject->DeviceObject, &uniDosName);
	//DbgPrint("PID : %ld File : %wZ  %wZ\r\n", (ULONG64)CurrentProcessId, &uniDosName, &uniFilePath);
	return OB_PREOP_SUCCESS;
}



OB_PREOP_CALLBACK_STATUS
preCall(PVOID RegistrationContext, POB_PRE_OPERATION_INFORMATION pOperationInformation)
{
	
	HANDLE pid = PsGetProcessId((PEPROCESS)pOperationInformation->Object);
	char szProcName[128] = { 0 };

	if (pOperationInformation->ObjectType != *PsProcessType)
	{
		return OB_PREOP_SUCCESS;
	}
	
	
	//DbgPrint("Process: %s", GetProcessNameFromPid(pid));
	
	strcpy(szProcName, GetProcessNameFromPid(pid)  );

	/*
	if (!_stricmp(szProcName, "ccccccccccc.exe"))
	{
		if (pOperationInformation->Operation == OB_OPERATION_HANDLE_CREATE)
		{
			if ((pOperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_TERMINATE) == PROCESS_TERMINATE)
			{
				//Terminate the process, such as by calling the user-mode TerminateProcess routine..
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_TERMINATE;
			}
			
			if ((pOperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_OPERATION) == PROCESS_VM_OPERATION)
			{
				//Modify the address space of the process, such as by calling the user-mode WriteProcessMemory and VirtualProtectEx routines.
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_OPERATION;
			}
			
			if ((pOperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_READ) == PROCESS_VM_READ)
			{
				//Read to the address space of the process, such as by calling the user-mode ReadProcessMemory routine.
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_READ;
			}
			if ((pOperationInformation->Parameters->CreateHandleInformation.OriginalDesiredAccess & PROCESS_VM_WRITE) == PROCESS_VM_WRITE)
			{
				//Write to the address space of the process, such as by calling the user-mode WriteProcessMemory routine.
				pOperationInformation->Parameters->CreateHandleInformation.DesiredAccess &= ~PROCESS_VM_WRITE;
			}
		}
	}
	*/

	//strcpy(szProcName, GetProcessImageNameByProcessID((ULONG)pid));
	//DbgPrint("Process: %s",szProcName);
	
	return OB_PREOP_SUCCESS;
}



UNICODE_STRING  GetFilePathByFileObject(PVOID FileObject)
{
	POBJECT_NAME_INFORMATION ObjetNameInfor;
	if (NT_SUCCESS(IoQueryFileDosDeviceName((PFILE_OBJECT)FileObject, &ObjetNameInfor)))
	{
		return ObjetNameInfor->Name;
	}
}
VOID EnableObType(POBJECT_TYPE ObjectType)
{
	POBJECT_TYPE_TEMP  ObjectTypeTemp = (POBJECT_TYPE_TEMP)ObjectType;
	ObjectTypeTemp->TypeInfo.SupportsObjectCallbacks = 1;
}




NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegisterPath)
{
	NTSTATUS Status = STATUS_UNSUCCESSFUL;

	PDEVICE_OBJECT pMyDevice;

	DbgPrint("___[Empire Kernel Load]___");

	
	RtlInitUnicodeString(&deviceNameUnicodeString, L"\\Device\\Empire");
	Status = IoCreateDevice(DriverObject, 4, &deviceNameUnicodeString, FILE_DEVICE_UNKNOWN, 0, TRUE, &pMyDevice);
	if (!NT_SUCCESS(Status))
	{
		DbgPrint("Failed to create the device!\n");
		return Status;
	}

	RtlInitUnicodeString(&linkNameUnicodeString, L"\\DosDevices\\Empire");
	Status = IoCreateSymbolicLink(&linkNameUnicodeString, &deviceNameUnicodeString);
	if (!NT_SUCCESS(Status))
	{
		DbgPrint("Failed to create the symlink\n");
		return Status;
	}


#ifdef _WIN64  
	PLDR_DATA_TABLE_ENTRY64 ldr;
	ldr = (PLDR_DATA_TABLE_ENTRY64)
		DriverObject->DriverSection;
#else  
	PLDR_DATA_TABLE_ENTRY ldr;
	ldr = (PLDR_DATA_TABLE_ENTRY)
		DriverObject->DriverSection;
#endif  
	ldr->Flags |= 0x20;


	//ProtectFileByObRegisterCallbacks(); //x64?



	for (int nIndex = 0; nIndex < IRP_MJ_MAXIMUM_FUNCTION; nIndex++)
	{
		DriverObject->MajorFunction[nIndex] = DefaultPass;

	}

	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = MyControl;



	if (NULL == ZwQueryInformationProcess) {

		UNICODE_STRING routineName;

		RtlInitUnicodeString(&routineName, L"ZwQueryInformationProcess");

		ZwQueryInformationProcess =
			(QUERY_INFO_PROCESS)MmGetSystemRoutineAddress(&routineName);

		if (NULL == ZwQueryInformationProcess) {
			DbgPrint("Cannot resolve ZwQueryInformationProcess\n");
		}
	}



	Status = PsSetLoadImageNotifyRoutine(&MyLoadImageNotifyRoutine);







	Process = PsGetCurrentProcess();
	Thread = PsGetCurrentThread();

	ptr = (PULONG)Thread;

	// Locate the ApcState structure

	for (i = 0; i<512; i++)
	{
		if (ptr[i] == (ULONG)Process)
		{
			ApcState = CONTAINING_RECORD(&ptr[i], KAPC_STATE, Process); // Get the actual address of KAPC_STATE
			ApcStateOffset = (ULONG)ApcState - (ULONG)Thread; // Calculate the offset of the ApcState structure

			break;
		}
	}






	DriverObject->DriverUnload = UnLoadDriver;
	Status = STATUS_SUCCESS;

	return Status;
}





NTSTATUS UnLoadDriver(PDRIVER_OBJECT DriverObject)
{

	NTSTATUS Status = STATUS_SUCCESS;
	DbgPrint("___[Empire Kernel Unload Success!]___");
	IoDeleteSymbolicLink(&linkNameUnicodeString);
	IoDeleteDevice(DriverObject->DeviceObject);

	PsRemoveLoadImageNotifyRoutine(&MyLoadImageNotifyRoutine);



	


Exit0:
	return Status;
}
